<%args>
	$username    => undef
	$password    => undef
	$session_id  => undef
	$tourn_id    => undef
	$event_id    => undef
	$round_id    => undef
	$school_id   => undef
	$category_id => undef
	$from        => undef
</%args>
<%init>

	use Scalar::Util "reftype";
	use utf8;

	# I hate this.
	our $no_return;
	undef $no_return;

	if ($round_id) {
		$no_return = $round_id;
	} else {
		$no_return = $from;
	}

	use JSON -convert_blessed_universally;

	my ($person, $tourn, $session, $perms) = $m->comp(
		"login_api.mas",
		tourn_id   => $tourn_id,
		username   => $username,
		password   => $password,
		session_id => $session_id
	);

	my $tz = $tourn->tz;
	$tz = "UTC" unless $tz;

	my $now       = DateTime->now(time_zone => $tz);
	my $nowstring = DateTime::Format::MySQL->format_datetime($now);
	my $req       = Apache2::Request->new($r);
	my @handles   = $r->upload;
	my $upload    = $req->upload($handles[0]);

	$m->print("<div id=\"wrapper\">");
	$m->print("<div id=\"content\">");
	my %settings = $tourn->all_settings();

    $m->comp("/register/data/menu.mas",
        tourn          => $tourn,
		tourn_settings => \%settings,
        person         => $person,
        whoami         => 'import_native',
	);

	my $dbh = Tab::DBI->db_Main();

	$m->print("<div class=\"main\">");
	&outlog("<h2>Uploading data</h2>");

	$m->print("<span class='nospace upload_scroll'>");
	$m->flush_buffer() unless $no_return;

	unless ($upload) {
		&errorlog("<p>No data upload sent, cannot process anything!</p>");
		$m->abort();
	}

	my $contents;
	$upload->slurp($contents);

	my $json = JSON->new->allow_nonref->convert_blessed;
	my %filter;

	my $jdata = eval {
		$json->pretty->decode($contents);
	};

	unless ($jdata) {
		&outlog("<h4>Data uploaded was invalid</h4>\n");
		$m->abort();
	}

	if ($jdata->{public}) {
		&outlog("<h2 class='redtext centeralign semibold martopmuchmore'>DATA FILE INVALID</h2>");
		&outlog("<p class='bigger martopmore'>This datafile contains the publicly generated data for a tournament,<p>");
		&outlog("<p>not complete data, and will therefore really mess up your tournament if you try to load it into Tabroom.</p>");
		&outlog("<p class='bigger'>Please upload only datafiles generated by an administrator-side operation, not the public interface</p>");
		$m->abort();
	}

	my $default_year = Tab::school_year();

	&outlog("<h4>Tournament: ".$tourn->name."</h4>\n");
	my $timestamp = parse_date($jdata->{backup_created});

	&outlog("<p class='specific'>Data file was created on ");
	$m->comp("/funclib/showdt.mas", dt => $timestamp);
	&outlog(" by ".$jdata->{creator}."</p>");

	# Shared Database functions

	Tab::EntryStudent->columns(TEMP => "entryid");
	Tab::EntryStudent->columns(TEMP => "studentid");

	Tab::EntryStudent->set_sql (by_school => "
		select entry_student.*, entry_student.entry entryid, entry_student.student studentid
		from entry_student, entry
		where entry_student.entry = entry.id
		and entry.school = ?
	");

	Tab::Concession->set_sql(rm_all => "
		delete from concession where school = ?
	");

	Tab::RoundSetting->set_sql(rm_all => "
		delete from round_setting where round = ?
	");

	Tab::PanelSetting->set_sql(rm_all => "
		delete panel_setting.* from panel_setting, panel where panel_setting.panel = panel.id and panel.round = ?
	");

	Tab::TournSetting->set_sql(rm_all => "
		delete from tourn_setting where tourn = ? and tag != 'nc_purchased'
	");

	Tab::RegionSetting->set_sql(rm_all => "
		delete from region_setting where region = ?
	");

	Tab::CategorySetting->set_sql(
		rm_all => "delete from category_setting where category = ?"
	);

	Tab::EventSetting->set_sql(
		rm_all => "delete from event_setting where event = ? and tag != 'weekend'"
	);

	Tab::ProtocolSetting->set_sql(rm_all => "
		delete from protocol_setting where protocol = ?
	");

	Tab::SchoolSetting->set_sql(rm_all => "
		delete from school_setting where school = ?
	");

	Tab::EntrySetting->set_sql(rm_all => "
		delete from entry_setting where entry = ?
	");

	Tab::JudgeSetting->set_sql(rm_all => "
		delete from judge_setting where judge = ?
	");

	Tab::JPoolSetting->set_sql(rm_all => "
		delete from jpool_setting where jpool = ?
	");

	Tab::StudentVote->set_sql(rm_all => "
		delete from student_vote where panel = ?
	");

	my $school_entries_sth = $dbh->prepare("
		select entry.id from entry where school = ?
	");

	my $event_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, entry
		where rating.entry = entry.id
			and entry.event = ?
	");

	my $school_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, entry
		where rating.entry = entry.id
			and entry.school = ?
	");

	my $category_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, judge
		where rating.judge = judge.id
			and judge.category = ?
	");

	my $school_judge_ratings_sth = $dbh->prepare("
		select
			rating.id, rating.entry, rating.judge, rating.ordinal, rating.rating_tier, rating.percentile
		from rating, judge
		where rating.judge = judge.id
			and judge.school = ?
	");

	my $update_rating_sth = $dbh->prepare("
		update rating
		set ordinal = ?, percentile = ?, rating_tier = ?, rating_subset = ?, side = ?
		where entry = ? and judge = ?
	");

	my $insert_rating_sth = $dbh->prepare("insert into rating
		(type, entered, tourn, ordinal, percentile, rating_tier, rating_subset,  side, entry, judge)
		VALUES ('entry', NOW(), ".$tourn->id.", ?, ?, ?, ?, ?, ?, ?)
	");

	my $delete_rating_sth = $dbh->prepare("delete from rating where entry = ? and judge = ? ");

	Tab::Score->set_sql(rm_all => "
		delete score.* from panel, ballot, score
		where panel.round = ?
			and panel.id = ballot.panel
			and ballot.id = score.ballot
	");

	Tab::Ballot->set_sql(rm_all => "
		delete ballot.* from panel, ballot
		where panel.round = ?
			and panel.id = ballot.panel
	");

	Tab::Panel->set_sql(rm_all => "
		delete from panel where panel.round = ?
	");

	Tab::RoomStrike->set_sql( by_site => "
		select rs.*
		from room_strike rs, room
		where rs.room = room.id
			and room.site = ?
			and rs.tourn = ?
	");

	unless (
		$jdata->{event_only}
		|| $jdata->{round_only}
		|| $jdata->{school_only}
		|| $jdata->{category_only}
	) {


		#TOURN DATA

		my $start_dt = parse_date($jdata->{start});
		my $end_dt = parse_date($jdata->{end});

		my $reg_start_dt = parse_date($jdata->{reg_start});
		my $reg_end_dt = parse_date($jdata->{reg_end});

		&outlog("<p class='action'> Updating tournament</p>");

		$tourn->name($jdata->{name}) if $jdata->{name};
		$tourn->tz($jdata->{tz}) if $jdata->{tz};
		$tourn->start($start_dt) if $start_dt;

		$tourn->end($end_dt) if $end_dt;
		$tourn->reg_start($reg_start_dt) if $reg_start_dt;
		$tourn->reg_end($reg_end_dt) if $reg_end_dt;

		my $hidden = $jdata->{hidden};
		$hidden = 0 unless $hidden;
		$tourn->hidden($hidden);

		&outlog("<p class='specific'>Loaded tournament data changes</p>");

		$tourn->update();

		if ($jdata->{settings})  {

			#TOURN SETTINGS
			Tab::TournSetting->sql_rm_all->execute($tourn->id);

			&outlog("<p class='specific'> Loading ".scalar @{$jdata->{settings}}." tournament settings </p>");

			foreach my $jsetting (@{$jdata->{settings}}) {
				my @reply = parse_setting($jsetting);
				$tourn->setting(@reply) if @reply;
			}
		}

	} elsif ($jdata->{round_only}) {
		&outlog("<p class='specific'>Update one round only</p>");
	} elsif ($jdata->{event_only}) {
		&outlog("<p class='specific'>Update event(s) only</p>");
	} elsif ($jdata->{school_only}) {
		&outlog("<p class='specific'>Update school(s) only</p>");
		unless ($perms->{"owner"} || $perms->{"tabber"}) {
			$m->comp("/funclib/abort.mas",
				message => "Only users with tournament wide tabber access may upload tournament wide data backups."
			);
		}
	}

	if ($jdata->{whole}) {
		unless ($perms->{"owner"} || $perms->{"tabber"}) {
			$m->comp("/funclib/abort.mas",
				message => "Only users with tournament wide tabber access may upload tournament wide data backups."
			);
		}
		&outlog("<p class='action'>Whole tournament mode active</p>");
	}

	my %translator;
	my @categories = $tourn->categories();
	my %category_by_id = map {$_->id => $_} @categories;
	my %category_by_name = map {$_->name => $_} @categories;
	my %category_by_abbr = map {$_->abbr => $_} @categories;

	my @protocols = $tourn->protocols;
	my %protocol_by_id = map {$_->id => $_} @protocols;
	my %protocol_by_name = map {$_->name => $_} @protocols;

	my $default_site;
	my @sites = $tourn->sites;
	my %site_by_id = map {$_->id => $_} @sites;
	my %site_by_name = map {$_->name => $_} @sites;

	#TIEBREAK SETS

	if ($jdata->{'tiebreak_sets'} && (not defined $jdata->{'protocols'})) {
		$jdata->{'protocols'} = $jdata->{'tiebreak_sets'};
	}

	if ($jdata->{protocols}) {

		&outlog("<p class='action'>Importing tiebreaker sets</p>");

		foreach my $protocol (@{$jdata->{protocols}}) {

			my $oprotocol;
			$oprotocol = $protocol_by_id{$protocol->{id}};

			unless ($oprotocol) {
				$oprotocol = $protocol_by_name{$protocol->{name}};
			}

			unless ($oprotocol) {
				$oprotocol = Tab::Protocol->create({
					name  => $protocol->{name},
					tourn => $tourn->id
				});
			} else {
				$oprotocol->name($protocol->{name});
				$oprotocol->update();
				#Prevent a double pump
				delete $protocol_by_id{$oprotocol->id};
			}

			$translator{protocol}{$protocol->{id}} = $oprotocol;

			&outlog("<p class='specific'>Tiebreak set ".$oprotocol->id." stored for ".$protocol->{id}." named ".$oprotocol->name."</p>");

			foreach my $tiebreak ($oprotocol->tiebreaks) {
				$tiebreak->delete();
			}

			#TIEBREAK SET SETTINGS
			Tab::ProtocolSetting->sql_rm_all->execute($oprotocol->id);

			if ($protocol->{settings})  {
				foreach my $jsetting (@{$protocol->{settings}}) {
					my @reply = parse_setting($jsetting);
					$oprotocol->setting(@reply) if @reply;
				}
			}
		}

		# TIEBREAKS

		# These are broken off to ensure that Child tiebreak sets with
		# derivative sets are available for translation.  No pruning required
		# because all tiebreakers are loaded fresh every time an import
		# happens.

		foreach my $protocol (@{$jdata->{protocols}}) {

			my $oprotocol = $translator{protocol}{$protocol->{id}};

			foreach my $tiebreak (@{$protocol->{tiebreaks}}) {

				my $child_set = $translator{protocol}{$tiebreak->{child}};

				$tiebreak->{count} = "all" unless $tiebreak->{count};
				$tiebreak->{truncate_smallest} = 0 unless $tiebreak->{truncate_smallest} > 0;

				Tab::Tiebreak->create({
					protocol          => $oprotocol->id,
					name              => $tiebreak->{name},
					priority          => $tiebreak->{priority},
					count             => $tiebreak->{count},
					highlow           => $tiebreak->{highlow},
					highlow_count     => $tiebreak->{highlow_count},
					count_round       => $tiebreak->{count_round},
					truncate          => $tiebreak->{truncate},
					truncate_smallest => $tiebreak->{truncate_smallest},
					multiplier        => $tiebreak->{multiplier},
					child             => $child_set
				});
			}
		}

		prune_unused( \%protocol_by_id, $translator{protocol}, $jdata->{protocols});

	} else {

		$translator{protocol} = \%protocol_by_id;
	}

	unless ($jdata->{round_only}) {

		#PATTERNS
		my @patterns = $tourn->patterns;
		my %pattern_by_id = map {$_->id => $_} @patterns;
		my %pattern_by_name = map {$_->name => $_} @patterns;

		if ($jdata->{patterns}) {

			foreach my $pattern (@{$jdata->{patterns}}) {

				my $opattern;
				$opattern = $pattern_by_id{$pattern->{id}};

				unless ($opattern) {
					$opattern = $pattern_by_name{$pattern->{name}};
				}

				if ($opattern) {

					$opattern->name($pattern->{name});
					$opattern->type($pattern->{tag});
					$opattern->max($pattern->{max});
					$opattern->exclude($pattern->{exclude});
					$opattern->update();
					delete $pattern_by_id{$opattern->id};

				} else {
					$opattern = Tab::Pattern->create({
						tourn   => $tourn->id,
						name    => $pattern->{name},
						type    => $pattern->{tag},
						max     => $pattern->{max},
						exclude => $pattern->{exclude}
					});
				}
				$translator{pattern}{$pattern->{id}} = $opattern;
			}

			prune_unused( \%pattern_by_id, $translator{pattern}, $jdata->{patterns});

		} else {
			$translator{pattern} = \%pattern_by_id;
		}
	}

	if ($jdata->{categories}) {

		&outlog("<p class='action'> Importing ".scalar @{$jdata->{categories}}." judge categories </p>");

		# CATEGORY CATEGORIES
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $category_by_id{$category->{id}};

			$ocategory = $category_by_abbr{$category->{abbr}}
				unless $ocategory || (not defined $category->{abbr});

			$ocategory = $category_by_name{$category->{name}}
				unless $ocategory || (not defined $category->{name});

			unless (
				$jdata->{event_only}
				|| $jdata->{round_only}
			) {

				if ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber") {

					if ($ocategory) {
						&outlog("<p class='specific'> Importing judge category ".$category->{name}." into matching category ".$ocategory->name."</p>");
						$ocategory->name($category->{name});
						$ocategory->abbr($category->{abbr});
						$ocategory->update();
						delete $category_by_id{$ocategory->id};
					} else {

						&outlog("<p class='specific'> No category found for name ".$category->{name}." Creating</p>");
						$ocategory = Tab::Category->create({
							tourn => $tourn->id,
							name  => $category->{name},
							abbr  => $category->{abbr},
						});
					}

					Tab::CategorySetting->sql_rm_all->execute($ocategory->id);

					if ($category->{settings})  {
						&outlog("<p class='specific'> Loading ".scalar @{$category->{settings}}." category settings </p>");

						foreach my $jsetting (@{$category->{settings}}) {
							my @reply = parse_setting($jsetting);
							next if $jsetting->{tag} eq "custom_rounds_per";
							$ocategory->setting(@reply) if @reply;
						}
					}
				}

			} elsif ($ocategory) {
				&outlog("<p class='specific'> Importing events in category ".$ocategory->name."</p>");
				$translator{category}{$category->{id}} = $ocategory;
			}

			if ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber") {

				unless ($jdata->{round_only}) {

					# PREFS AND PREF SHEETS
					my @rts;
					my %rt_by_id;
					my %rt_by_name;

					@rts = $ocategory->rating_tiers if $ocategory;
					%rt_by_id = map {$_->id => $_} @rts if @rts;
					%rt_by_name = map {$_->name => $_} @rts if @rts;

					# PREF TIERS
					if ($category->{rating_tiers}) {

						&outlog("<p class='action'> Importing ".scalar @{$category->{rating_tiers}}." pref tiers </p>");

						foreach my $rt (@{$category->{rating_tiers}}) {

							my $ort = $rt_by_id{$rt->{id}};
							$ort = $rt_by_name{$rt->{name}} unless $ort;

							foreach my $tag ("strike", "conflict", "start") {
								$rt->{$tag} = 0 unless $rt->{$tag} > 0;
							}

							unless ($ort) {
								$ort = Tab::RatingTier->create({
									category    => $ocategory->id,
									type        => $rt->{tag},
									name        => $rt->{name},
									description => $rt->{description},
									strike      => $rt->{strike},
									conflict    => $rt->{conflict},
									min         => $rt->{min},
									max         => $rt->{max},
									start       => $rt->{start},
								});

								&outlog("<p class='specific'> No rating tier found for ".$rt->{id}." ".$rt->{name}." RT $ort created</p>");

							} else {

								&outlog("<p class='specific'> Rating tier $ort found for  ".$rt->{id}." ".$rt->{name}."</p>");
								$ort->type($rt->{tag});
								$ort->name($rt->{name});
								$ort->description($rt->{description});
								$ort->strike($rt->{strike});
								$ort->conflict($rt->{conflict});
								$ort->min($rt->{min});
								$ort->max($rt->{max});
								$ort->start($rt->{start});
								$ort->update();
								delete $rt_by_id{$ort->id};
							}

							$translator{rating_tier}{$rt->{id}} = $ort;
						}

						prune_unused( \%rt_by_id, $translator{rating_tier}, $category->{rating_tiers});

					} elsif ($ocategory) {
						$translator{rating_tier} = \%rt_by_id;
						$translator{rating_tier_name}{$ocategory->id} = \%rt_by_name;
					}

					my @rss;
					my %rs_by_id;
					my %rs_by_name;

					@rss = $ocategory->rating_subsets if $ocategory;
					%rs_by_id = map {$_->id => $_} @rss if @rss;
					%rs_by_name = map {$_->name => $_} @rss if @rss;

					#RATING SUBSETS
					if ($category->{rating_subsets}) {
						foreach my $rs (@{$category->{rating_subsets}}) {

							my $ors = $rs_by_id{$rs->{id}};
							&outlog("<p class='specific'> No rating subset found for id ".$rs->{id}." Trying name ".$rs->{name}."</p>");
							$ors = $rs_by_name{$rs->{name}} unless $ors;

							unless ($ors) {
								$ors = Tab::RatingSubset->create({
									category => $ocategory->id,
									name     => $rs->{name}
								});
								&outlog("<p class='specific'> No rating subset found for ".$rs->{id}." ".$rs->{name}." RS $ors created</p>");
							} else {
								&outlog("<p class='specific'> Rating subset $ors found for  ".$rs->{id}." ".$rs->{name}."</p>");
								$ors->name($rs->{name});
								$ors->update();
							}

							$translator{rating_subset}{$rs->{id}} = $ors;
						}

						prune_unused( \%rs_by_id, $translator{rating_subset}, $category->{rating_subsets});

					} elsif ($ocategory) {
						$translator{rating_subset} = \%rs_by_id;
						$translator{rating_subset_name}{$ocategory->id} = \%rs_by_name;
					}

					$translator{category}{$category->{id}} = $ocategory;
				}
			}

			# EVENTS
			if ($ocategory && $category->{events} && (not defined $jdata->{round_only})) {

				&outlog("<p class='action'> Importing ".scalar @{$category->{events}}." events </p>");

				my @events = $ocategory->events();

				my %event_by_id = map {$_->id => $_} @events;
				my %event_by_name = map {$_->name => $_} @events;
				my %event_by_abbr = map {$_->abbr => $_} @events;

				my @tourn_events = $tourn->events();
				my %tourn_event_by_id = map {$_->id => $_} @tourn_events;
				my %tourn_event_by_name = map {$_->name => $_} @tourn_events;
				my %tourn_event_by_abbr = map {$_->abbr => $_} @tourn_events;

				EVENT:
				foreach my $event (@{$category->{events}}) {

					&outlog("<p class='specific'> Importing event ".$event->{abbr}."</p>");

					unless ($event->{type}) {
						&outlog("<p class='specific'> No event type listed for ".$event->{id}." Cannot import.</p>");
						next EVENT;
					}

					my $oevent = $event_by_id{$event->{id}};

					unless (
						$perms->{"owner"}
						|| $perms->{"tabber"}
						|| $perms->{category}{$ocategory} eq "tabber"
						|| $perms->{event}{$oevent} eq "tabber"
					) {
						&outlog("<p class='specific'> You do not have permissions to affect ".$event->{id}." Cannot import.</p>");
						next EVENT;
					}

					$oevent = $event_by_abbr{$event->{abbr}} unless $oevent;

					unless ($oevent) {
						if ( $event->{abbr} eq "DX" || $event->{abbr} eq "DX") {
							$oevent = $event_by_abbr{USX};
						} elsif ($event->{abbr} eq "FX") {
							$oevent = $event_by_abbr{IX};
						} elsif ($event->{abbr} eq "BQD") {
							$oevent = $event_by_abbr{BQ};
						}
					}

					$oevent = $event_by_name{$event->{name}} unless $oevent;

					unless ($oevent) {

						$oevent = $tourn_event_by_id{$event->{id}};

						$oevent = $tourn_event_by_abbr{$event->{abbr}} unless $oevent;

						unless ($oevent) {
							if ( $event->{abbr} eq "DX" || $event->{abbr} eq "DX") {
								$oevent = $tourn_event_by_abbr{USX};
							} elsif ($event->{abbr} eq "FX") {
								$oevent = $tourn_event_by_abbr{IX};
							} elsif ($event->{abbr} eq "BQD") {
								$oevent = $tourn_event_by_abbr{BQ};
							}
						}

						$oevent = $tourn_event_by_name{$event->{name}} unless $oevent;
					}

					if ($oevent && $oevent->category != $ocategory->id) {
						$oevent->category($ocategory->id);
						$oevent->update();
					}

					my $opattern = $translator{pattern}{$event->{pattern}};
					$opattern = 0 unless $opattern;

					my $orating_subset = $translator{rating_subset}{$event->{rating_subset}};
					$orating_subset = 0 unless $orating_subset;

					if ($oevent) {

						$oevent->category($ocategory->id);
						$oevent->name($event->{name});
						$oevent->abbr($event->{abbr});
						$oevent->type($event->{type});
						$oevent->fee($event->{fee});
						$oevent->pattern($opattern);
						$oevent->rating_subset($orating_subset);
						$oevent->update();

						#Prevent a double pump
						delete $event_by_id{$oevent->id};

					} else {

						&outlog("<p class='specific'> No event found for name ".$event->{name}." Abbr ".$event->{abbr}.". Creating</p>");

						$oevent = Tab::Event->create({
							tourn         => $tourn->id,
							category      => $ocategory->id,
							name          => $event->{name},
							abbr          => $event->{abbr},
							type          => $event->{type},
							fee           => $event->{fee},
							pattern       => $opattern,
							rating_subset => $orating_subset
						});
					}

					$translator{event}{$event->{id}} = $oevent;

					if ($event->{settings})  {

						Tab::EventSetting->sql_rm_all->execute($oevent->id);

						foreach my $jsetting (@{$event->{settings}}) {

							$jsetting->{tag} = "speaker_protocol" if $jsetting->{tag} eq "speaker_tbset";
							$jsetting->{tag} = "leadership_protocol" if $jsetting->{tag} eq "leadership_tbset";
							$jsetting->{tag} = "po_protocol" if $jsetting->{tag} eq "po_tbset";

							if (
								$jsetting->{tag} eq "speaker_protocol"
								|| $jsetting->{tag} eq "po_protocol"
								|| $jsetting->{tag} eq "leadership_protocol"
							) {
								my $set = $translator{protocol}{$jsetting->{value}};
								eval{ $oevent->setting($jsetting->{tag}, $set); };
							} else {
								my @reply = parse_setting($jsetting);
								eval{ $oevent->setting(@reply) };
							}
						}
					}
				}

				if ($jdata->{whole}) {

					&outlog("<p class='action'> Pruning unused events </p>");

					prune_unused(
						\%event_by_id,
						$translator{event},
						$category->{events}
					)

				}
			} elsif ($ocategory) {

				unless ($perms->{"owner"} || $perms->{"tabber"}) {
					next unless $perms->{category}{$ocategory} eq "tabber";
				}

				&outlog("<p class='action'> Using existing events </p>");
				my %event_by_id = map {$_->id => $_} $ocategory->events();
				$translator{event} = \%event_by_id;
			}
		}

		if ($jdata->{whole}) {


			&outlog("<p class='action'> Pruning unused categories </p>");

			prune_unused(
				\%category_by_id,
				$translator{category},
				$jdata->{categories}
			);
		}

	} elsif ($perms->{"owner"} || $perms->{"tabber"}) {

		$translator{category} = \%category_by_id;
		my %event_by_id = map {$_->id => $_} $tourn->events();
		$translator{event} = \%event_by_id;

		foreach my $ocategory ($tourn->categories) {

			my @judges = $ocategory->judges();
			my %judge_by_id = map {$_->id => $_} @judges;

			if ($translator{judge}) {
				$translator{judge} = { %{$translator{judge}}, %judge_by_id};
			} else {
				$translator{judge} = \%judge_by_id;
			}

			my @rts = $ocategory->rating_tiers;
			my %rt_by_id = map {$_->id => $_} @rts;
			my %rt_by_name = map {$_->name => $_} @rts;

			if ($translator{rating_tier}) {
				$translator{rating_tier} = { %{$translator{rating_tier}}, %rt_by_id};
			} else {
				$translator{rating_tier} = \%rt_by_id;
			}
			$translator{rating_tier_name}{$ocategory->id} = \%rt_by_name;

			my @rss = $ocategory->rating_subsets;
			my %rs_by_id = map {$_->id => $_} @rss;
			my %rs_by_name = map {$_->name => $_} @rss;

			if ($translator{rating_subset}) {
				$translator{rating_subset} = { %{$translator{rating_subset}}, %rs_by_id};
			} else {
				$translator{rating_subset} = \%rs_by_id;
			}

			$translator{rating_subset_name}{$ocategory->id} = \%rs_by_name;

			my @entries = $m->comp("/funclib/category_entries.mas", category => $ocategory);
			my %entry_by_id = map {$_->id => $_} @entries;

			if ($translator{entry}) {
				$translator{entry} = {%{$translator{entry}}, %entry_by_id};
			} else {
				$translator{entry} = \%entry_by_id;
			}

		}
	}

	#TIMESLOTS
	my @timeslots = $tourn->timeslots;
	my %timeslot_by_id = map {$_->id => $_} @timeslots;
	my %timeslot_by_name = map {$_->name => $_} @timeslots;

	if ($jdata->{timeslots}
		 && ($perms->{"owner"} || $perms->{"tabber"})
	) {

		foreach my $timeslot (@{$jdata->{timeslots}}) {

			my $otimeslot;
			$otimeslot = $timeslot_by_id{$timeslot->{id}};

			unless ($otimeslot) {
				$otimeslot = $timeslot_by_name{$timeslot->{name}};
			}

			my $start = parse_date($timeslot->{start});
			my $end = parse_date($timeslot->{end});

			unless ($otimeslot) {
				$otimeslot = Tab::Timeslot->create({
					name  => $timeslot->{name},
					tourn => $tourn->id,
					start => $start,
					end   => $end
				});
			} else {
				$otimeslot->name($timeslot->{name});
				$otimeslot->start($timeslot->{start});
				$otimeslot->end($timeslot->{end});
				$otimeslot->update();

				#Prevent a double pump
				delete $timeslot_by_id{$otimeslot->id};
			}

			$translator{timeslot}{$timeslot->{id}} = $otimeslot;
		}

		if ($jdata->{whole}) {
			&outlog("<p class='action'> Pruning unused events </p>");
			prune_unused( \%timeslot_by_id, $translator{timeslot}, $jdata->{timeslots});
		}

	} else {

		$translator{timeslot} = \%timeslot_by_id;
	}

	# SITES

	if ($jdata->{sites}
		 && ($perms->{"owner"} || $perms->{"tabber"})
	) {

		foreach my $site (@{$jdata->{sites}}) {

			my $osite;
			$osite = $site_by_id{$site->{id}};

			unless ($osite) {
				$osite = $site_by_name{$site->{name}};
			}

			$site->{name} = $tourn->name." Site" unless $site->{name};

			if ($osite) {

				$osite->name($site->{name});
				$osite->update();

				#Double pump
				delete $site_by_id{$osite->id};

			} else {

				my $circuit = $tourn->circuits->first;
				$circuit = 6 unless $circuit;

				$osite = Tab::Site->create({
					name    => $site->{name},
					circuit => $circuit
				});
			}

			$translator{site}{$site->{id}} = $osite;
			$default_site = $osite unless $default_site;

			my @rooms = $osite->rooms;
			my %room_by_id = map {$_->id => $_} @rooms;
			my %room_by_name = map {$_->name => $_} @rooms;

			# ROOMS
			if ($site->{rooms}) {

				ROOM:
				foreach my $room (@{$site->{rooms}}) {

					my $oroom;
					$oroom = $room_by_id{$room->{id}};

					unless ($oroom) {
						$oroom = $room_by_name{$room->{name}};
					}

					if ($oroom) {
						if (
							$room_by_name{$room->{name}}
							&& ($room_by_name{$room->{name}} != $oroom)
						) {
							$oroom = $room_by_name{$room->{name}};
						}
					}

					foreach my $tag ("ada", "inactive") {
						$room->{$tag} = 0 unless $room->{$tag};
					}

					if ($oroom) {

						$oroom->name($room->{name});
						$oroom->rowcount($room->{rows});
						$oroom->seats($room->{seats});

						$oroom->ada($room->{ada});
						$oroom->inactive($room->{inactive});

						$oroom->quality($room->{quality});
						$oroom->capacity($room->{capacity});
						$oroom->notes($room->{notes});
						$oroom->url($room->{url});

						$oroom->update();

					} else {

						$oroom = Tab::Room->create({
							site     => $osite->id,
							name     => $room->{name},
							rowcount => $room->{rows},
							seats    => $room->{seats},
							ada      => $room->{ada},
							inactive => $room->{inactive},
							quality  => $room->{quality},
							capacity => $room->{capacity},
							notes    => $room->{notes},
							url      => $room->{url},
						});
					}

					$translator{room}{$room->{id}} = $oroom;
				}
			}
		}

	} else {

		$translator{site} = \%site_by_id;
		$default_site = $sites[0];

		my @rooms;
		foreach my $site ($tourn->sites) {
			push @rooms, $site->rooms;
		}

		%{$translator{room}} = map {$_->id => $_} @rooms;
		%{$translator{roomname}} = map {$_->name => $_} @rooms;
	}

	unless ($jdata->{round_only}) {
		if ($perms->{"owner"} || $perms->{"tabber"}) {

			# WEEKENDS
			my @weekends = $tourn->weekends;
			my %weekend_by_id = map {$_->id => $_} @weekends;
			my %weekend_by_name = map {$_->name => $_} @weekends;

			if ($jdata->{weekends}) {

				foreach my $weekend (@{$jdata->{weekends}}) {

					next unless $weekend->{name};
					my $oweekend;
					$oweekend = $weekend_by_id{$weekend->{id}};

					unless ($oweekend) {
						$oweekend = $weekend_by_name{$weekend->{name}};
					}

					my $start           = parse_date($weekend->{start});
					my $end             = parse_date($weekend->{end});
					my $reg_start       = parse_date($weekend->{reg_start});
					my $reg_end         = parse_date($weekend->{reg_end});
					my $fine_deadline   = parse_date($weekend->{fine_deadline});
					my $freeze_deadline = parse_date($weekend->{freeze_deadline});
					my $judge_deadline  = parse_date($weekend->{judge_deadline});
					my $drop_deadline   = parse_date($weekend->{drop_deadline});

					next unless $start;
					next unless $end;
					next unless $reg_start;
					next unless $reg_end;
					next unless $fine_deadline;
					next unless $freeze_deadline;
					next unless $judge_deadline;
					next unless $drop_deadline;

					my $site = $translator{site}{$weekend->{site}};
					$site = $default_site unless $site;
					$site = 0 unless $site;

					if ($oweekend) {

						$oweekend->name($weekend->{name});
						$oweekend->state($weekend->{state});
						$oweekend->city($weekend->{city});
						$oweekend->end($end);
						$oweekend->start($start);
						$oweekend->reg_end($reg_end);
						$oweekend->reg_start($reg_start);
						$oweekend->drop_deadline($drop_deadline);
						$oweekend->freeze_deadline($freeze_deadline);
						$oweekend->judge_deadline($judge_deadline);
						$oweekend->fine_deadline($fine_deadline);
						$oweekend->site($site);

					} else {

						$oweekend = Tab::Weekend->create({
							name            => $weekend->{name},
							end             => $end,
							tourn           => $tourn,
							start           => $start,
							reg_end         => $reg_end,
							reg_start       => $reg_start,
							drop_deadline   => $drop_deadline,
							freeze_deadline => $freeze_deadline,
							judge_deadline  => $judge_deadline,
							fine_deadline   => $fine_deadline,
							site            => $site
						});
					}

					$translator{weekend}{$weekend->{id}} = $oweekend;
				}

				prune_unused( \%weekend_by_id, $translator{weekend}, $jdata->{weekends});
			} else {
				$translator{weekend} = \%weekend_by_id;
			}

			my @regions = $m->comp("/funclib/tourn_regions.mas", tourn => $tourn, circuit => $settings{"region_circuit"});
			my %region_by_id = map {$_->id => $_} @regions;
			my %region_by_name = map {$_->name => $_} @regions;
			my %region_by_code = map {$_->code => $_} @regions;

			# REGIONS
			if ($jdata->{regions}) {

				foreach my $region (@{$jdata->{regions}}) {

					my $oregion;
					$oregion = $region_by_id{$region->{id}};

					unless ($oregion) {
						$oregion = $region_by_code{$region->{code}};
					}

					unless ($oregion) {
						$oregion = $region_by_name{$region->{name}};
					}

					unless ($oregion) {

						$oregion = Tab::Region->create({
							tourn     => $tourn->id,
							name      => $region->{name},
							code      => $region->{code},
							circuit   => $region->{circuit},
						});

					} else {

						 $oregion->name($region->{name});
						 $oregion->code($region->{code});
						 $oregion->circuit($region->{circuit});
						 $oregion->update();
						delete $region_by_id{$oregion->id};
					}

					# REGION SETTINGS
					if ($region->{settings})  {
						Tab::RegionSetting->sql_rm_all->execute($oregion->id);
						foreach my $rsetting (@{$region->{settings}}) {
							my @reply = parse_setting($rsetting);
							$oregion->setting(@reply) if @reply;
						}
					}

					$translator{region}{$region->{id}} = $oregion;
				}

			} else {

				$translator{region} = \%region_by_id;
			}

			unless ($jdata->{"skip_content"}) {
				# CONCESSIONS
				my @concessions = $tourn->concessions;
				my %concession_by_id = map {$_->id => $_} @concessions;
				my %concession_by_name = map {$_->name => $_} @concessions;

				my %ctype_by_id;
				my %ctype_by_name;

				my %coption_by_id;
				my %coption_by_name;

				foreach my $concession (@concessions) {

					foreach my $ctype ($concession->types) {
						$ctype_by_id{$ctype->{id}} = $ctype;
						$ctype_by_name{$ctype->{name}} = $ctype;

						foreach my $option ($ctype->options) {
							$coption_by_id{$option->{id}} = $option;
							$coption_by_name{$option->{name}} = $option;
						}
					}
				}

				if ($jdata->{concessions}) {

					foreach my $concession (@{$jdata->{concessions}}) {

						my $oconcession = $concession_by_id{$concession->{id}};

						unless ($oconcession) {
							$oconcession = $concession_by_name{$concession->{name}};
						}

						unless ($oconcession) {
							$oconcession = Tab::Concession->create({
								name         => $concession->{name},
								price        => $concession->{price},
								description  => $concession->{description},
								deadline     => $concession->{deadline},
								cap          => $concession->{cap},
								school_cap   => $concession->{school_cap},
								billing_code => $concession->{billing_code}
							});

						} else {

							$oconcession->name($concession->{name});
							$oconcession->price($concession->{price});
							$oconcession->description($concession->{description});
							$oconcession->deadline($concession->{deadline});
							$oconcession->cap($concession->{cap});
							$oconcession->school_cap($concession->{school_cap});
							$oconcession->billing_code($concession->{billing_code});
							$oconcession->update();
						}

						$translator{concession}{$concession->{id}} = $oconcession;

						if ($concession->{types}) {

							foreach my $ctype (@{$concession->{types}}) {

								my $octype = $ctype_by_id{$ctype->{id}};

								unless ($octype) {
									$octype = $ctype_by_name{$ctype->{name}};
								}

								unless ($octype) {

									$octype = Tab::ConcessionType->create({
										name        => $ctype->{name},
										description => $ctype->{description},
										concession  => $oconcession->id
									});

								} else {

									$octype->name($ctype->{name});
									$octype->description($ctype->{description});
									$octype->concession($oconcession->id);
									$octype->update();

								}

								$translator{ctype}{$ctype->{id}} = $octype;

								foreach my $coption ($ctype->{options}) {

									next;

									my $ocoption = $coption_by_id{$coption->{id}};

									unless ($ocoption) {
										$ocoption = $coption_by_name{$coption->{name}};
									}

									unless ($ocoption) {

										$ocoption = Tab::ConcessionOption->create({
											name            => $ocoption->{name},
											description     => $ocoption->{description},
											disabled        => $ocoption->{disabled},
											concession_type => $octype->id
										});

									} else {

										$ocoption->name($ocoption->{name});
										$ocoption->description($ocoption->{description});
										$ocoption->disabled($ocoption->{disabled});
										$ocoption->concession_type($octype->id);
										$ocoption->update();
									}

									$translator{coption}{$coption->{id}} = $ocoption;

								}
							}
						}
					}

					prune_unused( \%concession_by_id, $translator{concession}, $jdata->{concessions});

				} else {
					$translator{concession} = \%concession_by_id;
					$translator{ctype} = \%ctype_by_id;
					$translator{coption} = \%coption_by_id;
				}
			}

			#Needed for school only uploads of judges and entries
			unless (keys %{$translator{event}}) {
				$translator{category} = \%category_by_id;
				my @events = $tourn->events();
				my %event_by_id = map {$_->id => $_} @events;
				$translator{event} = \%event_by_id;
			}

			my @schools = $tourn->schools();
			my %school_by_id = map {$_->id => $_} @schools;
			my %school_by_name = map {$_->name => $_} @schools;
			my %school_by_chapter;
			my %school_by_nsda;

			foreach my $school (@schools) {
				next unless $school->chapter > 0;
				$school_by_chapter{$school->chapter->id} = $school;
				next unless $school->chapter->nsda > 0;
				$school_by_nsda{$school->chapter->nsda} = $school;
			}

			Tab::Chapter->set_sql(by_tourn => "
				select chapter.*
					from chapter, school
				where school.tourn = ?
					and school.chapter = chapter.id
				order by chapter.name
			");

			my @chapters = Tab::Chapter->search_by_tourn($tourn->id);
			my %chapter_by_id = map {$_->id => $_} @chapters;
			my %chapter_by_name = map {$_->name => $_} @chapters;

			if ($jdata->{schools}) {

				&outlog("<h4 class='action'>REGISTRATION DATA</h4>");
				&outlog("<p class='action'> Importing ".scalar @{$jdata->{schools}}." school registrations</p>");

				my @actual_schools;

				# SCHOOLS
				SCHOOL:
				foreach my $school (@{$jdata->{schools}}) {

					my $oschool = $school_by_id{$school->{id}};

					unless ($oschool) {
						$oschool = $school_by_chapter{$school->{chapter}};
					}

					unless ($oschool) {
						$oschool = $school_by_nsda{$school->{nsda}};
					}

					unless ($oschool) {
						$oschool = $school_by_name{$school->{name}};
					}

					if ($oschool && $school->{nochange}) {

						$translator{school}{$school->{id}} = $oschool;

						$school_entries_sth->execute($oschool);
						my $results = $school_entries_sth->fetchall_hash();

						foreach my $entref (@{$results}) {
							$translator{entry}{$entref->{id}} = $entref->{id};
						}

						delete $school_by_id{$oschool};

						&outlog("<p class='specific'>".$school->{name}." was marked no change.  Skipped</p>");
						$m->flush_buffer() unless $no_return;
						next SCHOOL;
					}

					my $region = $translator{region}{$school->{region}};

					#CHAPTER
					my $ochapter = $chapter_by_id{$school->{chapter}};

					unless ($ochapter) {
						$ochapter = Tab::Chapter->retrieve($school->{chapter}) if $school->{chapter};
					}

					unless ($ochapter) {
						if ($school->{nsda}) {
							$ochapter = Tab::Chapter->search(nsda => $school->{nsda})->first;
						}
					}

					if ($school->{nsda} && (not defined $ochapter)) {
						$ochapter = $m->comp("/funclib/nsda/school_import.mas",
							nsda_school_id => $school->{nsda},
							silent         => 1
						);

						if ($ochapter != int($ochapter)) {
							undef $ochapter;
							$ochapter = Tab::Chapter->search(nsda => $school->{nsda})->first;
						}
					}

					unless ($ochapter) {

						$school->{nsda} = 0 unless $school->{nsda};
						$school->{district} = 0 unless $school->{district};

						$ochapter = Tab::Chapter->create({
							name     => $school->{name},
							state    => $school->{state},
							nsda     => $school->{nsda},
							district => $school->{district}
						});

						&outlog("<p class='specific'>No chapter with name ".$school->{name}." or NSDA ID ".$school->{nsda}." found.  Created $ochapter</p>");
					} else {

						$ochapter->nsda($school->{nsda});
						$ochapter->update();
					}

					$school->{onsite} = 0 unless $school->{onsite};

					unless ($oschool) {

						&outlog("<p class='specific'> Creating ".$school->{id}." ".$school->{name}." ");

						$oschool = Tab::School->create({
							name     => $school->{name},
							code     => $school->{code},
							onsite   => $school->{onsite},
							tourn    => $tourn,
							chapter  => $ochapter,
							state    => $school->{state},
							region   => $region,
							district => $school->{district}
						});

					} else {

						&outlog("<p class='specific'>School ".$oschool->name." found for ".$school->{id}." ".$school->{name}." ");

						$oschool->name($school->{name});
						$oschool->code($school->{code});
						$oschool->state($school->{state});
						$oschool->onsite($school->{onsite});
						$oschool->region($region);
						$oschool->district($school->{district});
						$oschool->update();
						#Double pump
						delete $school_by_id{$oschool->id};
					}

					$translator{school}{$school->{id}} = $oschool;
					push @actual_schools, $oschool;

					if ($oschool) {

						#SCHOOL SETTINGS
						if ($school->{settings})  {

							Tab::SchoolSetting->sql_rm_all->execute($oschool->id);

							foreach my $jsetting (@{$school->{settings}}) {
								my @reply = parse_setting($jsetting);
								next if $jsetting->{tag} eq "single_entry_letters";
								next if $jsetting->{tag} eq "category_contacts";

								if (@reply) {
									eval {
									$oschool->setting(@reply);
									};
								}
							}
						}

						# STUDENTS
						my @students = $ochapter->students();
						my %student_by_id = map {$_->id => $_} @students;
						my %student_by_nsda = map {$_->nsda => $_} @students;
						my %student_by_name = map {$_->first."-".$_->last => $_} @students;

						foreach my $student (@{$school->{students}}) {

							next unless $student->{first} && $student->{last};
							next if $translator{student}{$student->{id}};

							my $ostudent;
							my $hchapter;

							if ($student->{chapter} != $school->{chapter}) {
								# Hybrid alert

								#CHAPTER
								my $hchapter = $chapter_by_id{$student->{chapter}};

								unless ($hchapter) {
									$hchapter = Tab::Chapter->retrieve($student->{chapter}) if $student->{chapter};
								}

								if ($hchapter) {
									$ostudent = $hchapter->students( id => $student->{id} )->first;
									$ostudent = $hchapter->students( nsda => $student->{nsda} )->first unless $ostudent;
									$ostudent = $hchapter->students( first => $student->{first}, last => $student->{last} )->first unless $ostudent;
								}

							} else {
								$ostudent = $student_by_id{$student->{id}};
								$ostudent = $student_by_nsda{$student->{nsda}} unless $ostudent;
								$ostudent = $student_by_name{$student->{first}." ".$student->{last}} unless $ostudent;
							}

							my $already;

							unless ($ostudent) {

								my $grad_year = $student->{grad_year};
								$grad_year = $default_year->year unless $grad_year;
								$student->{person} = 0 unless $student->{person};

								my $schapter = $hchapter;
								$schapter = $ochapter unless $schapter;

								$ostudent = Tab::Student->create({
									chapter   => $schapter->id,
									first     => $student->{first},
									last      => $student->{last},
									middle    => $student->{middle},
									nsda      => $student->{nsda},
									person    => $student->{person},
									grad_year => $grad_year
								});

							} else {

								$already = $ostudent->nsda;

								$ostudent->first($student->{first});
								$ostudent->last($student->{last});
								$ostudent->middle($student->{middle}) if $student->{middle};
								$ostudent->nsda($student->{nsda}) if $student->{nsda} > 0;
								$ostudent->update();
								delete $student_by_id{$ostudent->id};
							}

							if ($student->{nsda} > 0 && ($student->{nsda} ne $already)) {
								$m->comp("/funclib/nsda/student_link.mas", person => $person, student => $ostudent, nsda => $student->{nsda}, silent => 1);
							}

							$translator{student}{$student->{id}} = $ostudent;
						}

						unless ($school->{"entries"}) {
							next SCHOOL;
						}


						# SCHOOL ENTRIES
						&outlog("| ".scalar @{$school->{entries}}." entries | ");

						my $found;
						my $created;
						my %es_by_entry;

						foreach my $es (Tab::EntryStudent->search_by_school( $oschool->id )) {
							$es_by_entry{$es->entryid}{$es->studentid} = $es;
						}

						my $total_entries = 0;
						my $total_prefs = 0;

						my %ratings;
						my $ratings_done;

						if ($school->{entries}) {

							foreach my $event_id (keys %{$translator{event}}) {

								# Entries are imported by event because there can be
								# code overlaps otherwise and that screws up the
								# importer.

								my $oevent = $translator{event}{$event_id};

								my @entries = $oschool->entries(event => $oevent->id);
								my %entry_by_id = map {$_->id => $_} @entries;
								my %entry_by_name = map {$_->name => $_} @entries;
								my %entry_by_code = map {$_->code => $_} @entries;

								foreach my $entry (@{$school->{entries}}) {

									next unless $entry->{event} == $event_id;

									my $oentry;
									$oentry = $entry_by_id{$entry->{id}};
									$oentry = $entry_by_name{$entry->{name}} unless $oentry;
									$oentry = $entry_by_code{$entry->{code}} unless $oentry;

									my $created_at = parse_date($entry->{created_at});

									foreach my $tag ("ada", "active", "dropped", "waitlist", "unconfirmed") {
										$entry->{$tag} = 0 unless $entry->{$tag} > 0;
									}

									unless ($oentry) {

										$oentry = Tab::Entry->create({
											school      => $oschool->id,
											event       => $oevent->id,
											name        => $entry->{name},
											code        => $entry->{code},
											ada         => $entry->{ada},
											created_at  => $created_at,
											dropped     => $entry->{dropped},
											waitlist    => $entry->{waitlist},
											unconfirmed => $entry->{unconfirmed}
										});

									} else {

										$oentry->name($entry->{name});
										$oentry->code($entry->{code});
										$oentry->event($oevent->id);
										$oentry->ada($entry->{ada});
										$oentry->created_at($created_at);
										$oentry->dropped($entry->{dropped});
										$oentry->waitlist($entry->{waitlist});
										$oentry->unconfirmed($entry->{unconfirmed});
										$oentry->update();
										delete $entry_by_id{$oentry};
									}

									$translator{entry}{$entry->{id}} = $oentry;
									$total_entries++ if $oentry;

									#ENTRY SETTINGS
									Tab::EntrySetting->sql_rm_all->execute($oentry);

									if ($entry->{'vacated'} == 1) {
										$oentry->setting('nsda_vacate', 1);
									}

									if ($entry->{settings})  {
										foreach my $jsetting (@{$entry->{settings}}) {
											my @reply = parse_setting($jsetting);
											if (@reply) {
												eval {
													$oentry->setting(@reply);
												};
											}
										}
									}

									#HYBRID STATUS
									my $hybrid_school;
									if ($entry->{hybrid}) {

										$hybrid_school = $translator{school}{$entry->{hybrid}};
										if ($hybrid_school) {

											unless (Tab::Strike->search(
												entry => $oentry,
												type  => "hybrid",
												school => $hybrid_school->id
											)) {

												Tab::Strike->create({
													entry  => $oentry,
													type   => "hybrid",
													tourn  => $tourn,
													school => $hybrid_school->id
												});
											}
										}
									}

									#ENTRY STUDENTS
									my %done;

									STUDENT:
									foreach my $student_id (@{$entry->{students}}) {

										next unless $student_id;
										next if $done{$student_id}++;
										my $ostudent = $translator{student}{$student_id};

										unless ($ostudent) {
											&outlog("<p>WARN: could not find student for $student_id</p>");
											next STUDENT;
										}

										if ($es_by_entry{$oentry}{$ostudent->id}) {
											# So I can spare this existing from deletion later
											delete $es_by_entry{$oentry}{$ostudent->id};
										} else {
											eval {
												Tab::EntryStudent->create({
													entry   => $oentry,
													student => $ostudent->id
												});
											};
										}
									}

									foreach my $spare (keys %{$es_by_entry{$oentry}}) {
										$es_by_entry{$oentry}{$spare}->delete();
										delete $es_by_entry{$oentry}{$spare};
									}

									#STRIKES
									if ($entry->{strikes}) {

										my @strikes = $oentry->strikes();
										my %strike_by_id = map {$_->id => $_} @strikes;
										my %strike_by_judge = map {$_->judge => $_} @strikes;
										my %strike_by_school = map {$_->school => $_} @strikes;

										STRIKE:
										foreach my $strike (@{$entry->{strikes}}) {

											my $ostrike;

											if ($strike->{tag} eq "hybrid") {

												my $oschool = $translator{school}{$strike->{school}};
												next STRIKE unless $oschool;

												$ostrike = $strike_by_id{$strike->{id}};
												$ostrike = $strike_by_school{$strike->{school}} unless $ostrike;

												if ($ostrike) {

													$ostrike->type($strike->{tag});
													$ostrike->conflict($strike->{conflict});
													$ostrike->conflictee($strike->{conflictee});
													$ostrike->registrant($strike->{registrant});
													$ostrike->school($oschool->id);
													$ostrike->entry($oentry);
													$ostrike->update();

												} else {

													$ostrike = Tab::Strike->create({
														type       => $strike->{tag},
														entry      => $oentry,
														conflict   => $strike->{conflict},
														conflictee => $strike->{conflictee},
														registrant => $strike->{registrant},
														school     => $oschool->id
													});
												}

											} else {

												my $ojudge = $translator{judge}{$strike->{judge}};

												next STRIKE unless $ojudge;

												$ostrike = $strike_by_id{$strike->{id}};
												$ostrike = $strike_by_judge{$strike->{judge}} unless $ostrike;

												if ($ostrike) {

													$ostrike->type($strike->{tag});
													$ostrike->conflict($strike->{conflict});
													$ostrike->conflictee($strike->{conflictee});
													$ostrike->registrant($strike->{registrant});
													$ostrike->judge($ojudge->id);
													$ostrike->entry($oentry);
													$ostrike->update();

												} else {

													$ostrike = Tab::Strike->create({
														entry      => $oentry,
														type       => $strike->{tag},
														conflict   => $strike->{conflict},
														conflictee => $strike->{conflictee},
														registrant => $strike->{registrant},
														judge      => $ojudge->id
													});
												}
											}

											$translator{strike}{$strike->{id}} = $ostrike;
										}

										prune_unused( \%strike_by_id, $translator{strike}, $entry->{strikes});
									}

									# SCHOOL ENTRY RATINGS aka PREFS
									if ($entry->{ratings}) {

										unless ($ratings_done++) {
											$school_ratings_sth->execute($oschool);
											foreach my $result (@{$school_ratings_sth->fetchall_hash}) {
												$ratings{$result->{"entry"}}{$result->{"judge"}}{$result->{"side"}} = $result;
											}
											$school_ratings_sth->finish();
										}

										$total_prefs++;
										my $ocategory = $oevent->category;

										RATING:
										foreach my $rating (@{$entry->{ratings}}) {

											$rating = clean_rating($rating, $nowstring, \%translator, $ocategory);

											next RATING unless $rating->{entry};
											next RATING unless $rating->{judge};
											next RATING unless ($rating->{rating_tier} > 0 || $rating->{ordinal} > 0);
											next RATING if $filter{$rating->{entry}}{$rating->{judge}}{$rating->{side}}++;

											if ($ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{id}) {

												$update_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);

												delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};

											} else {

												$insert_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);
											}
										}
									}
								}
								prune_unused( \%entry_by_id, $translator{entry}, $school->{entries});
							}
						}

						foreach my $entry (keys %ratings) {
							if ($ratings{$entry}) {
								foreach my $judge (keys %{$ratings{$entry}}) {
									if (keys %{$ratings{$entry}{$judge}}) {
										$delete_rating_sth->execute($entry, $judge);
									}
								}
							}
						}

						#SCHOOL STRIKES
						if ($school->{strikes}) {

							my @strikes = $oschool->strikes(type => "school");
							my %strike_by_id = map {$_->id => $_} @strikes;
							my %strike_by_judge = map {$_->judge => $_} @strikes;
							my %strike_by_school = map {$_->school => $_} @strikes;

							STRIKE:
							foreach my $strike (@{$school->{strikes}}) {

								my $ostrike;
								my $ojudge = $translator{judge}{$strike->{judge}};

								next STRIKE unless $ojudge;

								$ostrike = $strike_by_id{$strike->{id}};
								$ostrike = $strike_by_judge{$strike->{judge}} unless $ostrike;

								if ($ostrike) {

									$ostrike->type($strike->{tag});
									$ostrike->conflict($strike->{conflict});
									$ostrike->conflictee($strike->{conflictee});
									$ostrike->registrant($strike->{registrant});
									$ostrike->judge($ojudge->id);
									$ostrike->school($oschool->id);
									$ostrike->update();

								} else {

									$ostrike = Tab::Strike->create({
										school     => $oschool->id,
										type       => $strike->{tag},
										conflict   => $strike->{conflict},
										conflictee => $strike->{conflictee},
										registrant => $strike->{registrant},
										judge      => $ojudge->id
									});
								}

								$translator{strike}{$strike->{id}} = $ostrike;
							}

							prune_unused( \%strike_by_id, $translator{strike}, $school->{strikes});
						}

						&outlog(" Imported $total_entries entries</p>");
						if ($total_prefs) {
							&outlog(" Imported $total_prefs pref sheets</p>");
						}

						# SCHOOL JUDGES

						# Ordinarily the judges are stored with the categories to
						# account for neutral/hired judges but if you are importing a
						# school on its own this includes the judges here.

						if ($school->{judges}) {

							my @chapter_judges;

							if ($oschool->chapter) {
								@chapter_judges = $oschool->chapter->chapter_judges();
							}

							my %cjs_by_id = map {$_->id => $_} @chapter_judges;
							my %cjs_by_person = map {$_->person => $_} @chapter_judges;
							my %cjs_by_nsda = map {$_->nsda => $_} @chapter_judges;
							my %cjs_by_name = map {$_->first."-".$_->last => $_} @chapter_judges;

							&outlog("<p class='specific'> Loading ".scalar @{$school->{judges}}." judges. | ");

							my $judge_count;
							undef %ratings;
							undef $ratings_done;

							foreach my $category_id (keys %{$translator{category}}) {

								my $ocategory = $translator{category}{$category_id};
								my @judges = $oschool->judges( category => $ocategory->id);

								my %judge_by_id = map {$_->id => $_} @judges;
								my %judge_by_person = map {$_->person => $_} @judges;
								my %judge_by_name = map {$_->first."-".$_->last => $_} @judges;
								my %judge_by_nsda;

								foreach my $judge (@judges) {
									next unless $judge->chapter_judge > 0;
									next unless $judge->chapter_judge->nsda > 0;
									$judge_by_nsda{$judge->chapter_judge->nsda} = $judge;
								}

								foreach my $judge (@{$school->{judges}}) {

									next if $translator{judge}{$judge->{id}};
									next unless $judge->{category} == $category_id;

									my $ojudge = $judge_by_id{$judge->{id}};

									unless ($ojudge) {
										$ojudge = $judge_by_person{$judge->{person}} if $judge->{person} > 0;
									}

									unless ($ojudge) {
										$ojudge = $judge_by_nsda{$judge->{nsda}} if $judge->{nsda} > 0;
									}

									unless ($ojudge) {
										$ojudge = $judge_by_name{$judge->{name}};
									}

									# Chapter Judge link if possible
									my $ocj;
									$ocj = $ojudge->chapter_judge if $ojudge && $ojudge->chapter_judge > 0;

									unless ($ocj) {
										$ocj = $cjs_by_id{$judge->{chapter_judge}};
										$ocj = $cjs_by_person{$judge->{person}} unless $ocj;
										$ocj = $cjs_by_nsda{$judge->{nsda}} unless $ocj;
										$ocj = $cjs_by_name{$judge->{first}."-".$judge->{last}} unless $ocj;
									}

									#nulls, whiny nulls.
									foreach my $flag ("active", "ada", "school", "person") {
										$judge->{$flag} = 0 unless $judge->{$flag} > 0;
									}

									my $alt_category = $translator{category}{$judge->{alt_category}};
									my $covers = $translator{category}{$judge->{covers}};

									unless ($ojudge) {

										$ojudge = Tab::Judge->create({
											code          => $judge->{code},
											middle        => $judge->{middle},
											first         => $judge->{first},
											last          => $judge->{last},
											category      => $ocategory->id,
											alt_category  => $alt_category,
											covers        => $covers,
											active        => $judge->{active},
											ada           => $judge->{ada},
											person        => $judge->{person},
											obligation    => $judge->{obligation},
											hired         => $judge->{hired},
											school        => $oschool->id,
											chapter_judge => $ocj
										});

									} else {

										$ojudge->code($judge->{code});
										$ojudge->middle($judge->{middle});
										$ojudge->first($judge->{first});
										$ojudge->last($judge->{last});
										$ojudge->category($ocategory);
										$ojudge->alt_category($alt_category);
										$ojudge->covers($covers);
										$ojudge->active($judge->{active});
										$ojudge->ada($judge->{ada});
										$ojudge->person($judge->{person});
										$ojudge->obligation($judge->{obligation});
										$ojudge->hired($judge->{hired});
										$ojudge->school($oschool);
										$ojudge->chapter_judge($ocj);

										$ojudge->update();
									}

									$translator{judge}{$judge->{id}} = $ojudge;
									$judge_count++ if $ojudge;

									#SCHOOL JUDGE SETTINGS
									Tab::JudgeSetting->sql_rm_all->execute($ojudge->id);

									if ($judge->{settings})  {
										foreach my $jsetting (@{$judge->{settings}}) {
											if ($jsetting->{tag} eq "tab_rating") {
												my $value = $translator{entry}{$jsetting->{value}};
												$ojudge->setting("tab_rating", $value) if $value;
											} else {
												my @reply = parse_setting($jsetting);
												eval{$ojudge->setting(@reply);};
											}
										}
									}

									#JUDGE STRIKES
									if ($judge->{strikes}) {

										my @strikes = $ojudge->strikes();
										my %strike_by_id = map {$_->id => $_} @strikes;
										my %strike_by_school = map {$_->school => $_} @strikes;
										my %strike_by_entry = map {$_->entry => $_} @strikes;

										STRIKE:
										foreach my $strike (@{$judge->{strikes}}) {

											my $ostrike;
											$ostrike = $strike_by_id{$strike->{id}};

											unless ($ostrike) {
												$ostrike = $strike_by_school{$strike->{school}} if $strike->{school};
											}

											unless ($ostrike) {
												$ostrike = $strike_by_entry{$strike->{entry}} if $strike->{entry};
											}

											my $oschool   = $translator{school}{$strike->{school}} if $strike->{school};
											my $oentry    = $translator{entry}{$strike->{entry}} if $strike->{entry};
											my $oevent    = $translator{event}{$strike->{event}} if $strike->{event};
											my $oregion   = $translator{region}{$strike->{region}} if $strike->{region};
											my $otimeslot = $translator{timeslot}{$strike->{timeslot}} if $strike->{timeslot};

											next STRIKE if $strike->{tag} eq "entry" && (not defined $oentry);
											next STRIKE if $strike->{tag} eq "event" && (not defined $oevent);
											next STRIKE if $strike->{tag} eq "school" && (not defined $oschool);
											next STRIKE if $strike->{tag} eq "region" && (not defined $oregion);
											next STRIKE if $strike->{tag} eq "timeslot" && (not defined $otimeslot);

											my $start_dt = parse_date($strike->{start});
											my $end_dt = parse_date($strike->{end});

											if ($ostrike) {

												$ostrike->judge($ojudge->id) if $ojudge;
												$ostrike->type($strike->{tag});
												$ostrike->conflict($strike->{conflict});
												$ostrike->conflictee($strike->{conflictee});
												$ostrike->registrant($strike->{registrant});

											} else {

												$ostrike = Tab::Strike->create({
													judge      => $ojudge->id,
													type       => $strike->{tag},
													conflict   => $strike->{conflict},
													conflictee => $strike->{conflictee},
													registrant => $strike->{registrant}
												});
											}

											$ostrike->school($oschool->id) if $oschool;
											$ostrike->entry($oentry) if $oentry;
											$ostrike->event($oevent->id) if $oevent;
											$ostrike->region($oregion->id) if $oregion;
											$ostrike->timeslot($otimeslot->id) if $otimeslot;
											$ostrike->start($start_dt) if $start_dt;
											$ostrike->end($end_dt) if $end_dt;

											$ostrike->district($strike->{district}) if $strike->{district};
											$ostrike->shift($strike->{shift}) if $strike->{shift};

											$ostrike->update();

											$translator{strike}{$strike->{id}} = $ostrike;
										}
										prune_unused( \%strike_by_id, $translator{strike}, $judge->{strikes});
									}

									# JUDGE BASED PREF SHEETS PREFS RATINGS

									if ($judge->{ratings}) {

										unless ($ratings_done++) {
											$school_judge_ratings_sth->execute($oschool);
											foreach my $result (@{$school_judge_ratings_sth->fetchall_hash}) {
												$ratings{$result->{"entry"}}{$result->{"judge"}}{$result->{"side"}} = $result;
											}
											$school_judge_ratings_sth->finish();
										}

										$total_prefs++;

										RATING:
										foreach my $rating (@{$judge->{ratings}}) {

											$rating = clean_rating($rating, $nowstring, \%translator, $ocategory);

											next RATING unless $rating->{entry};
											next RATING unless $rating->{judge};
											next RATING unless ($rating->{rating_tier} > 0 || $rating->{ordinal} > 0);
											next RATING if ($filter{$rating->{entry}}{$rating->{judge}}{$rating->{side}}++);

											if ($ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{id}) {

												$update_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);

												delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};

											} else {

												$insert_rating_sth->execute(
													$rating->{ordinal},
													$rating->{percentile},
													$rating->{rating_tier},
													$rating->{subset},
													$rating->{side},
													$rating->{entry},
													$rating->{judge},
												);
											}
										}
									}
								}

								prune_unused( \%judge_by_id, $translator{judge}, $school->{judges});
							}

							foreach my $entry (keys %ratings) {
								if ($ratings{$entry}) {
									foreach my $judge (keys %{$ratings{$entry}}) {
										if (keys %{$ratings{$entry}{$judge}}) {
											$delete_rating_sth->execute($entry, $judge);
										}
									}
								}
							}


							&outlog(" Found or created $judge_count judges. | ");
						}

						# INVOICES (NSDA ONLY)

						my @invoices = $oschool->invoices;
						my %invoice_by_id = map {$_->id => $_} @invoices;
						my %invoice_by_blusynergy = map {$_->blusynergy => $_} @invoices;

						if ($school->{invoices}) {

							foreach my $invoice (@{$school->{invoices}}) {

								my $oinvoice = $invoice_by_id{$invoice->{id}};
								next unless $invoice->{total} > 0;

								unless ($oinvoice) {
									$oinvoice = $invoice_by_blusynergy{$invoice->{blusynergy}};
								}

								unless ($oinvoice) {

									$oinvoice = Tab::Invoice->create({
										school     => $oschool->id,
										blusynergy => $invoice->{blusynergy},
										blu_number => $invoice->{blu_number},
										total      => $invoice->{total},
										paid       => $invoice->{paid},
										details    => $invoice->{details}
									});

								} else {

									$oinvoice->school($oschool->id);
									$oinvoice->blusynergy($invoice->{blusynergy});
									$oinvoice->blu_number($invoice->{blu_number});
									$oinvoice->total($invoice->{total});
									$oinvoice->paid($invoice->{paid});
									$oinvoice->details($invoice->{details});
									$oinvoice->update();
								}

								$translator{invoice}{$invoice->{id}} = $oinvoice;
							}
							prune_unused( \%invoice_by_id, $translator{invoice}, $school->{invoices});
						}

						# CONCESSION PURCHASES ORDERS
						my %purchase_by_id = map {$_->id => $_} $oschool->purchases;

						if ( (not defined $jdata->{"skip-content"}) && $school->{purchases}) {

							foreach my $purchase (@{$school->{purchases}}) {

								next unless $purchase->{quantity} > 0;
								my $opurchase = $purchase_by_id{$purchase->{id}};

								my $concession = $translator{concession}{$purchase->{concession}};
								next unless $concession;

								my $invoice = $translator{invoice}{$purchase->{invoice}};

								unless ($opurchase) {

									$opurchase = Tab::ConcessionPurchase->create({
										school     => $oschool->id,
										quantity   => $purchase->{quantity},
										placed     => $purchase->{placed},
										fulfilled  => $purchase->{fulfilled},
										concession => $concession->id,
										invoice    => $invoice
									});

								} else {

									$opurchase->school($oschool->id);
									$opurchase->quantity($purchase->{quantity});
									$opurchase->placed($purchase->{placed});
									$opurchase->fulfilled($purchase->{fulfilled});
									$opurchase->concession($concession->id);
									$opurchase->invoice($invoice);
									$opurchase->update();

								}

								$translator{purchase}{$purchase->{id}} = $opurchase;
								my %option_by_id = map {$_->concession_option->id => $_} $opurchase->purchase_options();
								my %done;

								foreach my $option ($purchase->{options}) {

									next if $option_by_id{$option};
									my $ooption = $translator{coption}{$option};
									next unless $ooption;
									$done{$ooption->id}++;

									Tab::ConcessionPurchaseOption->create({
										concession_purchase => $opurchase->id,
										concession_option   => $ooption->id,
									});
								}

								foreach my $option (keys %option_by_id) {
									next if $done{$option};
									$option_by_id{$option}->delete;
									delete $option_by_id{$option};
								}
							}
						}

						prune_unused( \%purchase_by_id, $translator{purchase}, $school->{purchases});
					}
				}

				prune_unused( \%school_by_id, $translator{school}, $jdata->{schools}) if $jdata->{whole};

				# FINES FEES AND PAYMENTS
				my @fines = $tourn->fines;

				if ($jdata->{school_only}) {
					undef @fines;
					foreach my $school (@actual_schools) {
						push @fines, $school->fines();
					}
				}

				my %fine_by_id = map {$_->id => $_} @fines;
				my %fine_by_school_reason = map {$_->school."-".$_->reason => $_} @fines;

				if ($jdata->{fines}) {

					&outlog("<p class='action'>Importing payments and fees</p>");

					FINE:
					foreach my $fine (@{$jdata->{fines}}) {

						my $school = $translator{school}{$fine->{school}};

						if ($fine->{school} && (not defined $school)) {
							#Do not prune fines out of scope and move on
							delete $fine_by_id{$fine->{id}};
							next FINE;
						}

						my $region = $translator{region}{$fine->{region}};
						my $judge  = $translator{judge}{$fine->{judge}};

						my $ofine = $fine_by_id{$fine->{id}};

						unless ($ofine) {
							$ofine = $fine_by_school_reason{$fine->{school}."-".$fine->{reason}};
						}

						my $deleted_at = parse_date($fine->{deleted_at});
						my $levied_at = parse_date($fine->{levied_at});

						$fine->{deleted} = 0 unless $fine->{deleted};
						$fine->{payment} = 0 unless $fine->{payment};

						unless ($ofine) {

							$ofine = Tab::Fine->create({
								reason     => $fine->{reason},
								amount     => $fine->{amount},
								payment    => $fine->{payment},
								levied_by  => $fine->{levied_by},
								levied_at  => $levied_at,
								deleted    => $fine->{deleted},
								deleted_by => $fine->{deleted_by},
								deleted_at => $deleted_at,
								tourn      => $tourn->id,
								school     => $school,
								region     => $region,
								judge      => $judge,
								invoice    => $fine->{invoice}
							});

						} else {

							$ofine->reason($fine->{reason});
							$ofine->amount($fine->{amount});
							$ofine->payment($fine->{payment});
							$ofine->levied_at($levied_at);
							$ofine->levied_by($fine->{levied_by});
							$ofine->deleted($fine->{deleted});
							$ofine->deleted_by($fine->{deleted_by});
							$ofine->deleted_at($deleted_at);
							$ofine->tourn($tourn);
							$ofine->school($school);
							$ofine->region($region);
							$ofine->judge($judge);
							$ofine->invoice($fine->{invoice});
							$ofine->update();

							delete $fine_by_id{$ofine->id};
						}

						$translator{fine}{$fine->{id}} = $ofine;
					}

					foreach my $fine (@{$jdata->{fines}}) {
						next unless $fine->{parent};
						my $ofine = $translator{fine}{$fine->{id}};
						my $oparent = $translator{fine}{$fine->{parent}};

						if ($ofine && $oparent) {
							$ofine->parent($oparent);
							$ofine->update();
						}
					}

					prune_unused( \%fine_by_id, $translator{fine}, $jdata->{fines})
						if $jdata->{school_only};
				}

				prune_unused( \%fine_by_id, $translator{fine}, $jdata->{fines});

			} else {

				$translator{school} = \%school_by_id;
				$translator{region} = \%region_by_id;
				my %entry_by_id = $m->comp("/funclib/tourn_entries.mas", tourn => $tourn);
				$translator{entry} = \%entry_by_id;
			}

			if ($jdata->{whole} && (not defined $jdata->{"skip_content"})) {

				my @emails = $tourn->emails;
				my %email_by_id = map {$_->id => $_} @emails;
				my %email_by_subject = map {$_->subject => $_} @emails;

				#EMAILS
				if ($jdata->{emails}) {

					&outlog("<p class='action'>Importing tournament emails</p>");

					foreach my $email (@{$jdata->{emails}}) {

						next;

						my $oemail = $email_by_id{$email->{id}};

						unless ($oemail) {
							$oemail = $email_by_subject{$email->{subject}};
						}

						my $content = Tab::Utils::uncompress($email->{content}) if $email->{content};
						my $metadata = Tab::Utils::uncompress($email->{metadata}) if $email->{metadata};

						eval {
							unless ($oemail) {
								$oemail = Tab::Email->create({
									tourn	=> $tourn->id,
									subject  => $email->{subject},
									content  => $content,
									metadata => $metadata,
									sent_to  => $email->{sent_to},
									sent_at  => $email->{sent_at},
									sender   => $email->{sender}
								});
							} else {
								$oemail->subject($email->{subject});
								$oemail->content($content);
								$oemail->metadata($metadata);
								$oemail->sent_to($email->{sent_to});
								$oemail->sent_at($email->{sent_at});
								$oemail->sender($email->{sender});
								$oemail->update();
							}
						};
					}
				}

				prune_unused( \%email_by_id, $translator{email}, $jdata->{emails})
					if $jdata->{whole};

				my @webpages = $tourn->webpages;
				my %webpage_by_id = map {$_->id => $_} @webpages;
				my %webpage_by_title = map {$_->title => $_} @webpages;

				#WEBPAGES
				if ($jdata->{webpages}) {

					&outlog("<p class='action'>Importing tournament website data</p>");

					foreach my $webpage (@{$jdata->{webpages}}) {

						my $owebpage = $webpage_by_id{$webpage->{id}};

						unless ($owebpage) {
							$owebpage = $webpage_by_title{$webpage->{title}};
						}

						$webpage->{published} = 0 unless $webpage->{published};

						my $content = Tab::Utils::uncompress($webpage->{content}) if $webpage->{content};

						unless ($owebpage) {

							$owebpage = Tab::Webpage->create({
								tourn       => $tourn->id,
								title       => $webpage->{title},
								content     => $content,
								published   => $webpage->{published},
								special     => $webpage->{special},
								page_order  => $webpage->{page_order},
								last_editor => $webpage->{last_editor},
							});

						} else {

							$owebpage->title($webpage->{title});
							$owebpage->content($content);
							$owebpage->published($webpage->{published});
							$owebpage->special($webpage->{special});
							$owebpage->page_order($webpage->{page_order});
							$owebpage->last_editor($webpage->{last_editor});
							$owebpage->update();
						}

						$translator{webpage}{$webpage->{id}} = $owebpage;
					}

					foreach my $webpage (@{$jdata->{webpages}}) {
						next unless $webpage->{parent};
						my $owebpage = $translator{webpage}{$webpage->{id}};
						my $oparent = $translator{webpage}{$webpage->{parent}};
						$owebpage->parent($oparent);
						$owebpage->update();
					}
				}

				prune_unused( \%webpage_by_id, $translator{webpage}, $jdata->{webpages})
			}
		}
	}

	# EVENTS PART DEUX: ROUNDS AND RESULTS
	if ($jdata->{categories} && (not defined $jdata->{school_only})) {

		unless ($jdata->{event_only} || $jdata->{round_only}) {
			&outlog("<h4 class='martop action'>ROUNDS AND RESULTS</h4>");
		}

		my %cjs;

		CATEGORY:
		foreach my $category (@{$jdata->{categories}}) {

			my $ocategory = $translator{category}{$category->{id}};

			unless ($ocategory) {
				&outlog("<p class='error'> No category found for ID ".$category->{id}."?  Error in data, skipping</p>");
				next CATEGORY;
			}

			# CATEGORY JUDGES.  This is the ordinary way judges are imported
			# unless this is a single school import, to account for
			# neutral/hires.

			my @judges = $ocategory->judges();

			my %judge_by_id = map {$_->id => $_} @judges;
			my %judge_by_person = map {$_->person => $_} @judges;
			my %judge_by_name = map {$_->first."-".$_->last => $_} @judges;
			my %judge_by_nsda;

			foreach my $judge (@judges) {
				next unless $judge->chapter_judge > 0;
				next unless $judge->chapter_judge->nsda > 0;
				$judge_by_nsda{$judge->chapter_judge->nsda} = $judge;
			}

			if ($category->{judges}
				&& (not defined $jdata->{event_only})
				&& (not defined $jdata->{round_only})
				&& ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber")
			) {

				my %ratings;
				my $ratings_done;
				my $counter;

				&outlog("<p class='action'> Importing ".scalar @{$category->{judges}}." judges into category ".$ocategory->abbr."</p>");

				foreach my $judge (@{$category->{judges}}) {

					next if $translator{judge}{$judge->{id}};
					my $ojudge = $judge_by_id{$judge->{id}};

					unless ($ojudge) {
						$ojudge = $judge_by_person{$judge->{person}} if $judge->{person} > 0;
					}

					unless ($ojudge) {
						$ojudge = $judge_by_nsda{$judge->{nsda}} if $judge->{nsda} > 0;
					}

					unless ($ojudge) {
						$ojudge = $judge_by_name{$judge->{name}};
					}

					if ($category->{nochange} && $ojudge) {
						$translator{judge}{$judge->{id}} = $ojudge;
						delete $judge_by_id{$ojudge};
						next;
					}

					# Chapter Judge link if possible
					my $ocj;
					$ocj = $ojudge->chapter_judge if $ojudge && $ojudge->chapter_judge > 0;

					unless ($ocj) {

						my $school_id = $judge->{school};

						if ($school_id && $cjs{$school_id}) {

							$ocj = $cjs{$school_id}{id}{$judge->{chapter_judge}};
							$ocj = $cjs{$school_id}{person}{$judge->{person}} unless $ocj;
							$ocj = $cjs{$school_id}{nsda}{$judge->{nsda}} unless $ocj;
							$ocj = $cjs{$school_id}{name}{$judge->{first}."-".$judge->{last}} unless $ocj;

						} elsif ($school_id) {

							my $oschool = $translator{school}{$school_id};

							if ($oschool && $oschool->chapter) {

								my @chapter_judges = $oschool->chapter->chapter_judges();

								%{$cjs{$school_id}{id}} = map {$_->id => $_} @chapter_judges;
								%{$cjs{$school_id}{person}} = map {$_->person => $_} @chapter_judges;
								%{$cjs{$school_id}{nsda}} = map {$_->nsda => $_} @chapter_judges;
								%{$cjs{$school_id}{name}} = map {$_->first."-".$_->last => $_} @chapter_judges;
							}

						} else {
							$ocj = 0;
						}
					}

					#nulls, whiny nulls.
					foreach my $flag ("active", "ada", "school", "person") {
						$judge->{$flag} = 0 unless $judge->{$flag} > 0;
					}

					my $oschool = $translator{school}{$judge->{school}};
					$oschool = 0 unless $oschool > 0;

					my $alt_category = $translator{category}{$judge->{alt_category}};
					$alt_category = 0 unless $alt_category > 0;

					my $covers = $translator{category}{$judge->{covers}};
					$covers = 0 unless $covers > 0;

					unless ($ojudge) {

						$ojudge = Tab::Judge->create({
							code          => $judge->{code},
							middle        => $judge->{middle},
							first         => $judge->{first},
							last          => $judge->{last},
							active        => $judge->{active},
							ada           => $judge->{ada},
							obligation    => $judge->{obligation},
							hired         => $judge->{hired},
							person        => $judge->{person},
							school        => $oschool,
							category      => $ocategory,
							alt_category  => $alt_category,
							covers        => $covers,
							chapter_judge => $ocj
						});

					} else {

						$ojudge->code($judge->{code});
						$ojudge->middle($judge->{middle});
						$ojudge->first($judge->{first});
						$ojudge->last($judge->{last});
						$ojudge->active($judge->{active});
						$ojudge->ada($judge->{ada});
						$ojudge->person($judge->{person});
						$ojudge->obligation($judge->{obligation});
						$ojudge->hired($judge->{hired});

						$ojudge->school($oschool);
						$ojudge->category($ocategory);
						$ojudge->alt_category($alt_category);
						$ojudge->covers($covers);
						$ojudge->chapter_judge($ocj);

						$ojudge->update();
					}

					$translator{judge}{$judge->{id}} = $ojudge;

					# JUDGE SETTINGS
					Tab::JudgeSetting->sql_rm_all->execute($ojudge->id);

					if ($judge->{settings})  {
						foreach my $jsetting (@{$judge->{settings}}) {
							my @reply = parse_setting($jsetting);
							eval{$ojudge->setting(@reply)};
						}
					}

					unless ($counter < 5 || $counter % 10) {
						&outlog("<p class='action'> Imported ".$counter." judges so far.  Just did ".$judge->{"last"}."</p>");
						$m->flush_buffer() unless $no_return;
					}

					$counter++;
				}

				#If there are judges in scope here I must prune.
				prune_unused( \%judge_by_id, $translator{judge}, $category->{judges});

			} else {
				$translator{judge} = \%judge_by_id;
			}

			EVENT:
			foreach my $event (@{$category->{events}}) {

				my $oevent = $translator{event}{$event->{id}};

				unless(
					$perms->{"owner"}
					|| $perms->{"tabber"}
					|| $perms->{category}{$ocategory} eq "tabber"
					|| $perms->{event}{$oevent} eq "tabber"
				) {
					&outlog("<p class='error'> You do not have permission to upload to event ".$event->{id}.".  Skipping</p>");
					next EVENT;
				}

				unless ($oevent) {
					&outlog("<p class='error'> No event found for ID ".$event->{id}."?  Error in data, skipping</p>");
					next EVENT;
				}

				# EVENT ENTRIES:
				# If this is an event or category only file and therefore contains entries

				my $total_entries = 0;
				my $pref_count = 0;

				if ($event->{entries}) {

					&outlog("<h5 class='martop action'>ENTRIES</h5>");
					&outlog("<p class='action'> Importing ".scalar @{$event->{entries}}." entries for ".$oevent->name."</p>");

					my @students = $m->comp("/funclib/event_students.mas", event => $oevent);

					my %student_by_id = map {$_->id => $_} @students;
					my %student_by_nsda = map {$_->nsda => $_} @students;
					my %student_by_name = map {$_->first." ".$_->last => $_} @students;

					my @entries = $oevent->entries(event => $oevent->id);

					my %entry_by_id = map {$_->id => $_} @entries;
					my %entry_by_name = map {$_->name => $_} @entries;
					my %entry_by_code = map {$_->code => $_} @entries;

					my %es_by_entry;

					Tab::EntryStudent->set_sql( by_event => "
						select es.*, entry.id as entryid, es.student as studentid
						from entry_student es, entry
						where entry.event = ?
							and entry.id = es.entry
					");

					foreach my $es (Tab::EntryStudent->search_by_event( $oevent->id )) {
						$es_by_entry{$es->entryid}{$es->studentid} = $es;
					}

					my %ratings;
					my $ratings_done;

					ENTRY:
					foreach my $entry (@{$event->{entries}}) {

						my $oschool = $translator{school}{$entry->{school}};

						unless ($oschool) {
							&errorlog("NO SCHOOL FOUND FOR ENTRY ".$entry->{code}." ".$entry->{name}." Skipping</p>");
							next ENTRY;
						}

						my $oentry;
						$oentry = $entry_by_id{$entry->{id}};
						$oentry = $entry_by_name{$entry->{name}} unless $oentry;
						$oentry = $entry_by_code{$entry->{code}} unless $oentry;

						my $created_at = parse_date($entry->{created_at});

						undef $oentry if $oentry && $oentry->school != $oschool->id;

						foreach my $tag ("ada", "active", "dropped", "waitlist", "unconfirmed") {
							$entry->{$tag} = 0 unless $entry->{$tag} > 0;
						}

						unless ($oentry) {

							$oentry = Tab::Entry->create({
								school      => $oschool->id,
								event       => $oevent->id,
								name        => $entry->{name},
								code        => $entry->{code},
								ada         => $entry->{ada},
								dropped     => $entry->{dropped},
								waitlist    => $entry->{waitlist},
								unconfirmed => $entry->{unconfirmed}
							});

						} else {
							$oentry->name($entry->{name});
							$oentry->code($entry->{code});
							$oentry->event($oevent->id);
							$oentry->ada($entry->{ada});
							$oentry->dropped($entry->{dropped});
							$oentry->waitlist($entry->{waitlist});
							$oentry->unconfirmed($entry->{unconfirmed});
						}

						$oentry->created_at($created_at) if $created_at;
						$oentry->update();
						delete $entry_by_id{$oentry};

						$translator{entry}{$entry->{id}} = $oentry;
						$total_entries++ if $oentry;

						#ENTRY SETTINGS
						Tab::EntrySetting->sql_rm_all->execute($oentry);
						if ($entry->{settings})  {
							foreach my $jsetting (@{$entry->{settings}}) {
								my @reply = parse_setting($jsetting);
								$oentry->setting(@reply) if @reply;
							}
						}

						#HYBRID STATUS
						my $hybrid_school;
						if ($entry->{hybrid}) {

							$hybrid_school = $translator{school}{$entry->{hybrid}};
							if ($hybrid_school) {

								unless (Tab::Strike->search(
									entry  => $oentry,
									type   => "hybrid",
									school => $hybrid_school->id
								)) {

									Tab::Strike->create({
										entry  => $oentry,
										type   => "hybrid",
										tourn  => $tourn,
										school => $hybrid_school->id
									});
								}
							}
						}

						#ENTRY STUDENTS
						my %done;
						my $ochapter = $oschool->chapter;

						STUDENT:
						foreach my $student (@{$entry->{students}}) {

							next if $done{$student->{id}}++;

							my $ostudent;
							$ostudent = $student_by_id{$student->{id}};

							if ($ostudent) {
								if (($ostudent->chapter && $ostudent->chapter->id != $ochapter)
									&& ((not defined $hybrid_school) || ($hybrid_school->chapter == $ostudent->chapter))
								) {
									# Not a match
									undef $ostudent;
								}
							}

							$ostudent = $student_by_id{$student->{id}};
							$ostudent = $student_by_nsda{$student->{nsda}} unless $ostudent;
							$ostudent = $student_by_name{$student->{first}." ".$student->{last}} unless $ostudent;

							my $already;

							unless ($ostudent) {

								my $grad_year = $student->{grad_year};
								$grad_year = $default_year->year unless $grad_year;

								my $student_chapter = $ochapter;
								$student_chapter = $hybrid_school->chapter if $student->{hybrid} && $hybrid_school;

								$ostudent = Tab::Student->create({
									chapter   => $student_chapter->id,
									first     => $student->{first},
									last      => $student->{last},
									middle    => $student->{middle},
									nsda      => $student->{nsda},
									grad_year => $grad_year
								});

							} else {

								$already = $ostudent->nsda;
								$ostudent->first($student->{first});
								$ostudent->last($student->{last});
								$ostudent->middle($student->{middle}) if $student->{middle};
								$ostudent->nsda($student->{nsda}) if $student->{nsda} > 0;
								$ostudent->update();
								delete $student_by_id{$ostudent->id};
							}

							if ($student->{nsda} > 0 && ($student->{nsda} ne $already)) {
								$m->comp("/funclib/nsda/student_link.mas",
									student => $ostudent,
									nsda    => $student->{nsda},
									silent  => 1,
									person  => $person
								);
							}

							$translator{student}{$student->{id}} = $ostudent;

							if ($es_by_entry{$oentry}{$ostudent->id}) {
								# So I can spare this existing from deletion later
								delete $es_by_entry{$oentry}{$ostudent->id};
							} else {
								eval {
									Tab::EntryStudent->create({
										entry   => $oentry,
										student => $ostudent->id
									});
								};
							}
						}

						foreach my $spare (keys %{$es_by_entry{$oentry}}) {
							$es_by_entry{$oentry}{$spare}->delete();
							delete $es_by_entry{$oentry}{$spare};
						}

						#STRIKES
						if ($entry->{strikes}) {

							my @strikes = $oentry->strikes();
							my %strike_by_id = map {$_->id => $_} @strikes;
							my %strike_by_judge = map {$_->judge => $_} @strikes;
							my %strike_by_school = map {$_->school => $_} @strikes;

							STRIKE:
							foreach my $strike (@{$entry->{strikes}}) {

								my $ostrike;

								if ($strike->{tag} eq "hybrid") {

									my $oschool = $translator{school}{$strike->{school}};
									next STRIKE unless $oschool;

									$ostrike = $strike_by_id{$strike->{id}};
									$ostrike = $strike_by_school{$strike->{school}} unless $ostrike;

									if ($ostrike) {

										$ostrike->type($strike->{tag});
										$ostrike->conflict($strike->{conflict});
										$ostrike->conflictee($strike->{conflictee});
										$ostrike->registrant($strike->{registrant});
										$ostrike->school($oschool->id);
										$ostrike->entry($oentry);
										$ostrike->update();

									} else {

										$ostrike = Tab::Strike->create({
											type       => $strike->{tag},
											entry      => $oentry,
											conflict   => $strike->{conflict},
											conflictee => $strike->{conflictee},
											registrant => $strike->{registrant},
											school     => $oschool->id
										});
									}

								} else {

									my $ojudge = $translator{judge}{$strike->{judge}};

									next STRIKE unless $ojudge;

									$ostrike = $strike_by_id{$strike->{id}};
									$ostrike = $strike_by_judge{$strike->{judge}} unless $ostrike;

									if ($ostrike) {

										$ostrike->type($strike->{tag});
										$ostrike->conflict($strike->{conflict});
										$ostrike->conflictee($strike->{conflictee});
										$ostrike->registrant($strike->{registrant});
										$ostrike->judge($ojudge->id);
										$ostrike->entry($oentry);
										$ostrike->update();

									} else {

										$ostrike = Tab::Strike->create({
											entry      => $oentry,
											type       => $strike->{tag},
											conflict   => $strike->{conflict},
											conflictee => $strike->{conflictee},
											registrant => $strike->{registrant},
											judge      => $ojudge->id
										});
									}
								}

								$translator{strike}{$strike->{id}} = $ostrike;
							}

							prune_unused( \%strike_by_id, $translator{strike}, $entry->{strikes});
						}

						# EVENT ENTRY RATINGS aka PREFS
						if ($entry->{ratings}) {

							unless ($ratings_done++) {
								$event_ratings_sth->execute($oevent);
								foreach my $result (@{$event_ratings_sth->fetchall_hash}) {
									$ratings{$result->{"entry"}}{$result->{"judge"}}{$result->{"side"}} = $result;
								}
								$event_ratings_sth->finish();
							}

							RATING:
							foreach my $rating (@{$entry->{ratings}}) {

								$rating = clean_rating($rating, $nowstring, \%translator, $ocategory);

								next RATING unless $rating->{entry};
								next RATING unless $rating->{judge};
								next RATING unless ($rating->{rating_tier} > 0 || $rating->{ordinal} > 0);
								next RATING if $filter{$rating->{entry}}{$rating->{judge}}{$rating->{side}}++;

								if ($ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{id}) {

									$update_rating_sth->execute(
										$rating->{ordinal},
										$rating->{percentile},
										$rating->{rating_tier},
										$rating->{subset},
										$rating->{side},
										$rating->{entry},
										$rating->{judge},
									);

									delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};

								} else {
									$insert_rating_sth->execute(
										$rating->{ordinal},
										$rating->{percentile},
										$rating->{rating_tier},
										$rating->{subset},
										$rating->{side},
										$rating->{entry},
										$rating->{judge},
									);
								}
							}
						}
					}

					foreach my $entry (keys %ratings) {
						if ($ratings{$entry}) {
							foreach my $judge (keys %{$ratings{$entry}}) {
								if (keys %{$ratings{$entry}{$judge}}) {
									$delete_rating_sth->execute($entry, $judge);
								}
							}
						}
					}

					prune_unused( \%entry_by_id, $translator{entry}, $event->{entries});

					&outlog("<h5 class='martop action'>ROUNDS AND RESULTS</h5>");

					if ($pref_count > 0) {
						&outlog(" Imported $total_entries entries with $pref_count pref sheets</p>");
					} else {
						&outlog(" Imported $total_entries entries</p>");
					}

				} elsif ($jdata->{round_only} || $jdata->{event_only}) {

					%{$translator{entry}} = map {$_->id => $_} $oevent->entries();
					%{$translator{judge}} = map {$_->id => $_} $m->comp("/funclib/tourn_judges.mas", tourn => $tourn);
				}

				if ($event->{rounds}) {

					&outlog("<p class='action'> Importing ".scalar @{$event->{rounds}}." rounds in ".$oevent->name." </p>");

					my @rounds = $oevent->rounds();
					my %round_by_id = map {$_->id => $_} @rounds;
					my %round_by_name = map {$_->name => $_} @rounds;

					# Force the upload of a round into this spot whether it's
					# the original or no.

					if ($round_id && $jdata->{round_only} )  {
						my $target = $round_by_id{$round_id};
						$round_by_id{$jdata->{round_only}} = $target;
					}

					&outlog("<p style='padding-left: 32px;' class='action'>");
					my $haz_letters;

					# ROUNDS

					ROUND:
					foreach my $round (sort {$a->{name} <=> $b->{name}} @{$event->{rounds}}) {

						&outlog("Round ".$round->{name}." ".$round->{label}." -- ");

						my $oround;

						#Reverse these to avoid the constraint about one round per number per event
						$oround = $round_by_name{$round->{name}};
						if ($oround) {
							&outlog("Round ".$oround." found on name ".$round->{name}." -- ");
						}

						unless (defined $oround) {
							$oround = $round_by_id{$round->{id}};
							if ($oround) {
								&outlog("Round ".$oround." found on id ".$round->{id}." -- ");
							}
						}

						if ($oround && $round->{nochange}) {
							delete $round_by_id{$oround};
							$translator{round}{$round->{id}} = $oround;
							&outlog(" NO CHANGE flag set.  Skipping<br />");
							next ROUND;
						}

						my $otimeslot = $translator{timeslot}{$round->{timeslot}};

						unless ($otimeslot) {

							my $start = parse_date($round->{start_time});
							&outlog("<p class='error'> No timeslot found for ID ".$round->{timeslot}."?");

							if ($start) {
								my $end = $start->clone;
								$end->add(minutes => 90);

								$otimeslot = Tab::Timeslot->create({
									name  => "Round ".$round->{name},
									tourn => $tourn->id,
									start => $start,
									end   => $end
								});

								$translator{timeslot}{$round->{timeslot}} = $otimeslot;
								&outlog("<p>Created timeslot for round</p>");
							} else {
								&outlog("<p>Error in data, skipping round ".$round->{name}."</p>");
								next ROUND;
							}
						}

						my $site = $translator{site}{$round->{site}};
						$site = $default_site unless $site;

						unless ($round->{protocol}) {
							$round->{protocol} = $round->{tiebreak_set};
							$round->{protocol_name} = $round->{tiebreak_set_name};
						}

						my $protocol = $translator{protocol}{$round->{protocol}};

						#This facilitates importing foreign Districts results from Speechwire
						unless ($protocol) {
							$protocol = $protocol_by_name{$round->{protocol_name}};
						}

						unless ($protocol) {
							&outlog("<p class='error'> No tiebreak set found for ID ".$round->{protocol}." name ".$round->{protocol_name}."?  Error in data, skipping round ".$round->{name}."</p>");
							next ROUND;
						}

						my $start_time = parse_date($round->{start_time});
						my $created = parse_date($round->{created});

						if ($oround) {

							$oround->type($round->{type});
							$oround->name($round->{name});
							$oround->published($round->{published});

							$oround->post_primary($round->{post_primary});
							$oround->post_secondary($round->{post_secondary});
							$oround->post_feedback($round->{post_feedback});

							$oround->timeslot($otimeslot->id);
							$oround->site($round->{site});
							$oround->label($round->{label});
							$oround->flighted($round->{flighted});
							$oround->protocol($protocol);
							$oround->created_at($created) if $created;
							$oround->start_time($start_time) if $start_time;
							$oround->update();

							#Prevent a double pump
							delete $round_by_id{$oround->id};

						} else {

							&outlog("No round found for ID ".$round->{id}." name ".$round->{name}." so creating one. -- ");

							$oround = Tab::Round->create({
								event          => $oevent->id,
								type           => $round->{type},
								name           => $round->{name},
								published      => $round->{published},
								post_primary   => $round->{post_primary},
								post_secondary => $round->{post_secondary},
								post_feedback  => $round->{post_feedback},
								timeslot       => $otimeslot->id,
								created_at     => $created,
								start_time     => $start_time,
								site           => $round->{site},
								label          => $round->{label},
								flighted       => $round->{flighted},
								protocol   => $protocol->id,
							});
						}

						$translator{round}{$round->{id}} = $oround;

						Tab::RoundSetting->sql_rm_all->execute($oround->id);

						if ($round->{settings}) {
							foreach my $jsetting (@{$round->{settings}}) {
								eval {
									my @reply = parse_setting($jsetting);
									$oround->setting(@reply) if @reply;
								}
							}
						}
						Tab::Score->sql_rm_all->execute($oround->id);
						Tab::Ballot->sql_rm_all->execute($oround->id);
						Tab::PanelSetting->sql_rm_all->execute($oround->id);
						Tab::Panel->sql_rm_all->execute($oround->id);

						my $section_count;

						#SECTIONS PANELS AND FUN
						if ($round->{sections}) {

							foreach my $section (@{$round->{sections}}) {

								my $oroom = $translator{room}{$section->{room}};

								# Also to help foreign imports and Speechwire
								unless ($oroom) {
									$oroom = $translator{roomname}{$section->{room_name}};
								}

								$section->{bye} = 0 unless $section->{bye} > 0;

								if ( (not defined $oroom) && $section->{room_name}) {
									$oroom = Tab::Room->create({
										site     => $site->id,
										name     => $section->{room_name},
										ada      => 0,
										inactive => 0
									});
								}

								my $flight = $section->{flight} if $section->{flight} > 0;
								$flight = 1 unless $flight;

								if ($section->{letter}) {
									$haz_letters++;
								}

								my $osection = Tab::Panel->create({
									room        => $oroom,
									round       => $oround,
									letter      => $section->{letter},
									flight      => $flight,
									bye         => $section->{bye}
								});

								if ($section->{started}) {
									my $started_dt = parse_date($section->{started});
									$osection->started($started_dt) if $started_dt;
								}

								foreach my $psetting (@{$section->{settings}}) {
									my @reply = parse_setting($psetting);
									$osection->setting(@reply) if @reply;
								}

								$osection->publish($section->{publish}) if $section->{publish};
								$osection->bracket($section->{bracket}) if $section->{bracket};
								$osection->update();

								$translator{section}{$section->{id}} = $osection;
								my %done;

								#BALLOTS and SCORES
								if ($section->{ballots}) {

									my %taken;

									foreach my $ballot (@{$section->{ballots}}) {

										my $oentry = $translator{entry}{$ballot->{entry}};
										unless ($oentry) {
											next;
										}

										my $ojudge = $translator{judge}{$ballot->{judge}};

										unless (
											$ojudge
											|| $ballot->{bye}
											|| $osection->bye
										) {
											next;
										}

										$ojudge = 0 unless $ojudge;

										foreach my $tag (
											"side",
											"speakerorder",
											"chair",
											"bye",
											"forfeit",
											"tv",
											"audit",
											"started_by",
											"audited_by",
											"entered_by"
										) {
											$ballot->{$tag} = 0 unless $ballot->{$tag} > 0;
										}

										while ($taken{$ballot->{judge}."-".$ballot->{side}."-".$ballot->{speakerorder}}) {
											if ($oevent->type eq "debate" || $oevent->type eq "wsdc") {
												$ballot->{side}++
											} else {
												$ballot->{speakerorder}++;
											}
										}

										$taken{$ballot->{judge}."-".$ballot->{side}."-".$ballot->{speakerorder}}++;

										my $judge_started_dt = eval {
											return parse_date($ballot->{judge_started});
										};

										if ($person->id == 1 && $ojudge < 1 && (defined $ballot->{judge})) {
											$ojudge = $ballot->{judge};
										}

										next if $done{$ojudge}{$oentry}{$osection}++;

										my $oballot = Tab::Ballot->create({
											panel         => $osection->id,
											entry         => $oentry,
											judge         => $ojudge,
											side          => $ballot->{side},
											speakerorder  => $ballot->{speakerorder},
											judge_started => $judge_started_dt,
											started_by    => $ballot->{started_by},
											entered_by    => $ballot->{entered_by},
											audited_by    => $ballot->{audited_by},
											bye           => $ballot->{bye},
											chair         => $ballot->{chair},
											audit         => $ballot->{audit},
											forfeit       => $ballot->{forfeit},
											tv            => $ballot->{tv}
										});


										if ($ballot->{scores}) {

											foreach my $score (@{$ballot->{scores}}) {


												next unless (defined $score->{value});
												next unless $score->{tag};

												foreach my $tag ("speech", "position", "student", "speaker") {
													$score->{$tag} = 0 unless $score->{$tag} > 0;
												}

												my $oscore = Tab::Score->create({
													ballot   => $oballot->id,
													tag      => $score->{tag},
													value    => $score->{value},
													student  => $score->{speaker},
													speech   => $score->{speech},
													topic    => $score->{topic},
													content  => $score->{content},
													position => $score->{position}
												});
											}
										}
									}
								}

								if ($section->{student_votes}) {

									my %taken;

									Tab::StudentVote->sql_rm_all->execute($osection->id);

									foreach my $vote (@{$section->{student_votes}}) {

										my $oentry = $translator{entry}{$vote->{entry}};
										next unless $oentry;

										my $ovoter = $translator{entry}{$vote->{voter}};
										next unless $ovoter;

										my $entered_at = parse_date($vote->{entered_at});

										my $sv = Tab::StudentVote->create({
											tag        => $vote->{tag},
											panel      => $osection->id,
											value      => $vote->{value},
											entry      => $vote->{entry},
											voter      => $vote->{voter},
											entered_by => $vote->{entered_by},
											entered_at => $entered_at
										});
									}
								}

								$section_count++;
							}
						}

						unless ($haz_letters) {
							$m->comp("/funclib/panel_letters.mas", round => $oround);
						}

						&outlog(" $section_count sections done. <br />");
						$m->flush_buffer() unless $no_return;
					}

					unless ($jdata->{round_only}) {
						prune_unused(\%round_by_id, $translator{round}, $event->{rounds});
					}

				} else {
					&outlog("<p class='error'> No rounds for event ".$event->{abbr}.". Not importing ballots</p>");
				}

				#RESULT SETS

				my @rsets = $oevent->result_sets();
				my %rset_by_id =  map {$_->id => $_ } @rsets;
				my %rset_by_label =  map {$_->label => $_ } @rsets;

				if ($event->{result_sets}) {

					my @result_sets = eval {
						return @{$event->{result_sets}};
					};

					unless (@result_sets) {
						if ($event->{result_sets}{label}) {
							push @result_sets, $event->{result_sets};
						}
					}

					&outlog("<p class='action'> Importing ".scalar @result_sets." result sets in ".$oevent->name." </p>");

					foreach my $rset (@result_sets) {

						my $oresult_set;
						$oresult_set = $rset_by_id{$rset->{id}};

						unless ($oresult_set) {
							$oresult_set = $rset_by_label{$rset->{label}};
						}

						my $generated_dt = parse_date($rset->{generated});

						unless ($oresult_set) {

							$oresult_set = Tab::ResultSet->create({
								event     => $oevent->id,
								label     => $rset->{label},
								bracket   => $rset->{bracket},
								published => $rset->{published},
								coach     => $rset->{coach},
								generated => $generated_dt,
								tourn     => $tourn->id
							});

						} else {

							$oresult_set->event($oevent->id);
							$oresult_set->label($rset->{label});
							$oresult_set->bracket($rset->{bracket});
							$oresult_set->published($rset->{published});
							$oresult_set->coach($rset->{coach});
							$oresult_set->generated($generated_dt);
							$oresult_set->tourn($tourn->id);
							$oresult_set->update();

							#Prevent a double pump
							delete $rset_by_id{$oresult_set->id};

						}

						$translator{result_set}{$rset->{id}} = $oresult_set;

						my @results = $oresult_set->results();
						my %result_by_id = map {$_->id => $_} @results;

						my @result_keys = $oresult_set->result_keys();
						my %rkey_by_id = map {$_->id => $_} @result_keys;
						my %rkey_by_tag = map {$_->tag => $_} @result_keys;

						my %keys;

						if ($rset->{result_keys}) {

							my $okey;

							foreach my $rkey (@{$rset->{result_keys}}) {

								if ($rkey_by_id{$rkey->{id}}) {

									$okey = $rkey_by_id{$rkey->{id}};

									$okey->tag($rkey->{tag});
									$okey->description($rkey->{description});
									$okey->no_sort($rkey->{no_sort});
									$okey->sort_desc($rkey->{sort_desc});
									$okey->update();

									$keys{$rkey->{id}} = $okey;

								} elsif ($rkey_by_tag{$rkey->{tag}}) {

									$okey = $rkey_by_tag{$rkey->{tag}};

									$okey->description($rkey->{description});
									$okey->no_sort($rkey->{no_sort});
									$okey->sort_desc($rkey->{sort_desc});
									$okey->update();

									$keys{$rkey->{id}} = $okey;

								} else {

									$okey = Tab::ResultKey->create({
										result_set  => $oresult_set->id,
										tag         => $rkey->{tag},
										description => $rkey->{description},
										no_sort     => $rkey->{no_sort},
										sort_desc   => $rkey->{sort_desc}
									});

									$keys{$rkey->{id}} = $okey;
								}
							}

						} else {

							%keys = map { $_->id => $_ } $oresult_set->result_keys();
						}

						$translator{result_key} = \%keys;

						my $id = 1000;
						my $rkey_rank;

						if ($rset->{results}) {

							foreach my $result (@{$rset->{results}}) {

								unless ($result->{id}) {
									$result->{id} = $id++;
								};

								my $oentry   = $translator{entry}{$result->{entry}};
								my $ostudent = $translator{student}{$result->{student}};
								my $oschool  = $translator{school}{$result->{school}};
								my $oround   = $translator{round}{$result->{round}};

								my $oresult = $result_by_id{$result->{id}};

								unless ($oresult) {

									$oresult = Tab::Result->create({
										result_set => $oresult_set,
										entry      => $oentry,
										student    => $ostudent,
										school     => $oschool,
										round      => $oround,
										rank       => $result->{rank},
										place      => $result->{place},
										percentile => $result->{percentile}
									});

								} else {

									$oresult->result_set($oresult_set);
									$oresult->entry($oentry);
									$oresult->student($ostudent);
									$oresult->school($oschool);
									$oresult->round($oround);
									$oresult->rank($result->{rank});
									$oresult->place($result->{place});
									$oresult->percentile($result->{percentile});
									$oresult->update();
									delete $result_by_id{$oresult->id};
								}

								$translator{result}{$result->{id}} = $oresult;

								my @values = $oresult->values();
								my %value_by_id = map {$_->id => $_} @values;
								my %value_by_priority = map {$_->priority => $_} @values;

								if ($result->{values}) {

									foreach my $value (@{$result->{values}}) {

										my $ovalue = $value_by_id{$value->{id}};

										unless ($ovalue) {
											$ovalue = $value_by_priority{$value->{priority}};
										}

										$value->{no_sort} = 0 unless $value->{no_sort};
										$value->{sort_desc} = 0 unless $value->{sort_desc};

										my $rkey = $translator{'result_key'}{$value->{result_key}};

										unless ($value->{protocol}) {
											$value->{protocol} = $value->{tiebreak_set};
										}
										my $protocol = $translator{'protocol'}{$value->{protocol}};

										$protocol = 0 unless $protocol;
										$rkey = 0 unless $rkey;

										unless ($ovalue) {

											$ovalue = Tab::ResultValue->create({
												result       => $oresult->id,
												value        => $value->{value},
												priority     => $value->{priority},
												result_key   => $rkey,
												protocol => $protocol
											});

										} else {

											$ovalue->result($oresult->id);
											$ovalue->value($value->{value});
											$ovalue->priority($value->{priority});
											$ovalue->result_key($rkey);
											$ovalue->protocol($protocol);
											$ovalue->update();

											delete $value_by_id{$ovalue->id};
										}

										$translator{value}{$value->{id}} = $ovalue;
									}

								} else {

									unless ($rkey_rank) {
										$rkey_rank = Tab::ResultKey->create({
											result_set  => $oresult_set->id,
											tag         => "Ranking",
											description => "Placement in Ranking",
											no_sort     => 0,
											sort_desc   => 0
										});
									}

									my $ovalue = Tab::ResultValue->create({
										result       => $oresult->id,
										value        => $result->{rank},
										priority     => 1,
										result_key   => $rkey_rank,
										protocol => 0
									});
								}

								prune_unused( \%value_by_id, $translator{value}, $result->{values});
							}
						}
						prune_unused( \%result_by_id, $translator{result}, $rset->{results});
					}
					prune_unused( \%rset_by_id, $translator{result_set}, $event->{result_sets});
				}
				&outlog(" ...Event Done</p>");
				$m->flush_buffer() unless $no_return;
			}


			if ($category->{judges}
				&& (not defined $jdata->{event_only})
				&& (not defined $jdata->{round_only})
				&& ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber")
			) {

				my %ratings;
				my $ratings_done;
				my $counter;

				&outlog("<p class='action'> Importing ".scalar @{$category->{judges}}." strikes and prefs into ".$ocategory->abbr."</p>");

				my %no_change;

				foreach my $judge (@{$category->{judges}}) {

					my $ojudge = $translator{judge}{$judge->{id}};
					next unless $ojudge;

					if ($ojudge && $category->{nochange}) {
						$no_change{$ojudge}++;
						next;
					}

					#JUDGE STRIKES
					if ($judge->{strikes}) {

						my @strikes = $ojudge->strikes();
						my %strike_by_id = map {$_->id => $_} @strikes;
						my %strike_by_school = map {$_->school => $_} @strikes;
						my %strike_by_entry = map {$_->entry => $_} @strikes;

						STRIKE:
						foreach my $strike (@{$judge->{strikes}}) {

							my $ostrike;
							$ostrike = $strike_by_id{$strike->{id}};

							unless ($ostrike) {
								$ostrike = $strike_by_school{$strike->{school}} if $strike->{school};
							}

							unless ($ostrike) {
								$ostrike = $strike_by_entry{$strike->{entry}} if $strike->{entry};
							}

							my $oschool = $translator{school}{$strike->{school}} if $strike->{school};
							my $oentry = $translator{entry}{$strike->{entry}} if $strike->{entry};
							my $oevent = $translator{event}{$strike->{event}} if $strike->{event};
							my $oregion = $translator{region}{$strike->{region}} if $strike->{region};
							my $otimeslot = $translator{timeslot}{$strike->{timeslot}} if $strike->{timeslot};

							next STRIKE if $strike->{tag} eq "entry" && (not defined $oentry);
							next STRIKE if $strike->{tag} eq "event" && (not defined $oevent);
							next STRIKE if $strike->{tag} eq "school" && (not defined $oschool);
							next STRIKE if $strike->{tag} eq "region" && (not defined $oregion);
							next STRIKE if $strike->{tag} eq "timeslot" && (not defined $otimeslot);

							my $start_dt = parse_date($strike->{start});
							my $end_dt = parse_date($strike->{end});

							if ($ostrike) {

								$ostrike->judge($ojudge->id) if $ojudge;
								$ostrike->type($strike->{tag});
								$ostrike->conflict($strike->{conflict});
								$ostrike->conflictee($strike->{conflictee});
								$ostrike->registrant($strike->{registrant});

							} else {

								$ostrike = Tab::Strike->create({
									judge      => $ojudge->id,
									type       => $strike->{tag},
									conflict   => $strike->{conflict},
									conflictee => $strike->{conflictee},
									registrant => $strike->{registrant}
								});
							}

							$ostrike->school($oschool->id) if $oschool;
							$ostrike->entry($oentry) if $oentry;
							$ostrike->event($oevent->id) if $oevent;
							$ostrike->region($oregion->id) if $oregion;
							$ostrike->timeslot($otimeslot->id) if $otimeslot;
							$ostrike->start($start_dt) if $start_dt;
							$ostrike->end($end_dt) if $end_dt;

							$ostrike->district($strike->{district}) if $strike->{district};
							$ostrike->shift($strike->{shift}) if $strike->{shift};

							$ostrike->update();

							$translator{strike}{$strike->{id}} = $ostrike;
						}

						prune_unused( \%strike_by_id, $translator{strike}, $judge->{strikes});
					}

					# RATINGS PREFS
					if ($judge->{ratings} && (not defined $category->{nochange})) {

						unless ($ratings_done++) {
							$category_ratings_sth->execute($ocategory);
							foreach my $result (@{$category_ratings_sth->fetchall_hash}) {
								$result->{"side"} = 0 unless $result->{"side"};
								$ratings{$result->{"entry"}}{$result->{"judge"}}{$result->{"side"}} = $result;
							}
							$category_ratings_sth->finish();
						}

						RATING:
						foreach my $rating (@{$judge->{ratings}}) {

							$rating->{judge} = $judge->{id};
							$rating = clean_rating($rating, $nowstring, \%translator, $ocategory);

							next RATING unless $rating->{entry};
							next RATING unless $rating->{judge};
							next RATING unless ($rating->{rating_tier} > 0 || $rating->{ordinal} > 0);
							next RATING if $filter{$rating->{entry}}{$rating->{judge}}{$rating->{side}}++;

							if (
								$ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{ordinal} == $rating->{ordinal}
								&& $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{percentile} == $rating->{percentile}
								&& $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{rating_tier} == $rating->{rating_tier}
							) {
								delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};
								next RATING;
							}

							$rating->{ordinal} = 0 unless $rating->{ordinal};
							$rating->{percentile} = 0 unless $rating->{percentile};

							if ($ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}}{id}) {

								$update_rating_sth->execute(
									$rating->{ordinal},
									$rating->{percentile},
									$rating->{rating_tier},
									$rating->{subset},
									$rating->{side},
									$rating->{entry},
									$rating->{judge},
								);

								delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};

							} else {

								$insert_rating_sth->execute(
									$rating->{ordinal},
									$rating->{percentile},
									$rating->{rating_tier},
									$rating->{subset},
									$rating->{side},
									$rating->{entry},
									$rating->{judge},
								);
								delete $ratings{$rating->{entry}}{$rating->{judge}}{$rating->{side}};
							}
						}
					}

					unless ($counter < 5 || $counter % 10) {
						&outlog("<p class='action'> Import ".$counter." judge pref sheets so far.  Just did ".$judge->{"last"}."</p>");
						$m->flush_buffer() unless $no_return;
					}

					$counter++;
				}

				foreach my $entry (keys %ratings) {
					if ($ratings{$entry}) {
						foreach my $judge (keys %{$ratings{$entry}}) {
							next if $no_change{$judge};
							if (keys %{$ratings{$entry}{$judge}}) {
								$delete_rating_sth->execute($entry, $judge);
							}
						}
					}
				}

				#If there are judges in scope here I must prune.
				prune_unused( \%judge_by_id, $translator{judge}, $category->{judges});

			} else {
				$translator{judge} = \%judge_by_id;
			}


			unless (
				$jdata->{round_only}
				&& ($perms->{"owner"} || $perms->{"tabber"} || $perms->{category}{$ocategory} eq "tabber")
			) {

				&outlog("<p class='action'> Importing judge pools </p>");

				#JPOOLS JUDGE POOLS
				my @jpools = $ocategory->jpools;
				my %jpool_by_id = map { $_->id => $_ } @jpools;
				my %jpool_by_name = map { $_->name => $_ } @jpools;

				if ($category->{judge_pools}) {

					foreach my $jpool (@{$category->{judge_pools}}) {

						my $ojpool = $jpool_by_id{$jpool->{id}};

						unless ($ojpool) {
							$ojpool = $jpool_by_name{$jpool->{name}};
						}

						my $site = $translator{site}{$jpool->{site}};
						$site = 0 unless $site;

						unless ($ojpool) {

							$ojpool = Tab::JPool->create({
								category => $ocategory->id,
								name     => $jpool->{name},
								site     => $site
							});

						} else {
							$ojpool->category($ocategory->id);
							$ojpool->name($jpool->{name});
							$ojpool->site($site);
							$ojpool->update();
							delete $jpool_by_id{$ojpool->id};
						}

						$translator{jpool}{$jpool->{id}} = $ojpool;

						#JPOOL SETTINGS
						Tab::JPoolSetting->sql_rm_all->execute($ojpool->id);

						if ($jpool->{settings})  {
							foreach my $jsetting (@{$jpool->{settings}}) {
								my @reply = parse_setting($jsetting);
								eval{$ojpool->setting(@reply)};
							}
						}

						#JPOOL ROUNDS
						my %jpool_rounds =
							map { $_->round->id => $_ }
							Tab::JPoolRound->search(jpool => $ojpool->id);

						if ($jpool->{rounds}) {

							foreach my $round (@{$jpool->{rounds}}) {
								my $oround = $translator{round}{$round};

								if ($jpool_rounds{$oround}) {
									delete ($jpool_rounds{$oround});
								} else {
									Tab::JPoolRound->create({
										round => $oround->id,
										jpool => $ojpool->id
									});
								}
							}
						}

						foreach my $key (keys %jpool_rounds) {
							$jpool_rounds{$key}->delete();
						}

						#JPOOL JUDGES
						my %jpool_judges =
							map { $_->judge->id => $_ }
							Tab::JPoolJudge->search(jpool => $ojpool->id);

						if ($jpool->{judges}) {

							foreach my $judge (@{$jpool->{judges}}) {

								my $ojudge = $translator{judge}{$judge};
								next unless $ojudge;

								if ($jpool_judges{$ojudge}) {
									delete $jpool_judges{$ojudge};
								} else {
									Tab::JPoolJudge->create({
										judge => $ojudge->id,
										jpool => $ojpool->id
									});
								}
							}
						}

						foreach my $key (keys %jpool_judges) {
							$jpool_judges{$key}->delete();
						}
					}
					prune_unused( \%jpool_by_id, $translator{jpool}, $category->{judge_pools});
				}
			}
		}

		unless ($jdata->{round_only}) {

			#ROOM POOLS

			my @rpools = $tourn->rpools;
			my %rpool_by_id = map { $_->id => $_ } @rpools;
			my %rpool_by_name = map { $_->name => $_ } @rpools;

			&outlog("<p class='action'> Importing global room pools </p>");

			if ($jdata->{room_pools}) {

				RPOOL:
				foreach my $rpool (@{$jdata->{room_pools}}) {

					my $orpool = $rpool_by_id{$rpool->{id}};

					unless ($orpool) {
						$orpool = $rpool_by_name{$rpool->{name}};
					}

					my $site = $translator{site}{$rpool->{site}};
					$site = 0 unless $site;

					unless ($orpool) {

						$orpool = Tab::RPool->create({
							tourn => $tourn->id,
							name  => $rpool->{name}
						});

					} else {

						$orpool->name($rpool->{name});
						$orpool->update();
						delete $rpool_by_id{$orpool->id};
					}

					$translator{rpool}{$rpool->{id}} = $orpool;
					next unless $orpool;

					#RPOOL ROUNDS
					my %rpool_rounds = map { $_->round->id => $_ }
						Tab::RPoolRound->search(rpool => $orpool->id);

					if ($rpool->{rounds}) {
						foreach my $round (@{$rpool->{rounds}}) {

							my $oround = $translator{round}{$round};
							next unless $oround && $oround->id;

							if ($rpool_rounds{$oround}) {
								delete $rpool_rounds{$oround};
							} else {
								Tab::RPoolRound->create({
									round => $oround->id,
									rpool => $orpool->id
								});
							}
						}
					}

					#RPOOL ROOMS
					my %rpool_rooms = map { $_->room->id => $_ }
						Tab::RPoolRoom->search(rpool => $orpool->id);

					if ($rpool->{rooms}) {

						foreach my $room (@{$rpool->{rooms}}) {

							my $oroom = $translator{room}{$room};
							next unless $oroom > 0;

							if ($rpool_rooms{$oroom}) {
								delete $rpool_rooms{$oroom};
							} else {
								Tab::RPoolRoom->create({
									room  => $oroom->id,
									rpool => $orpool->id
								});
							}
						}
					}

					foreach my $key (keys %rpool_rooms) {
						$rpool_rooms{$key}->delete();
						delete $rpool_rooms{$key};
					}

					foreach my $key (keys %rpool_rounds) {
						$rpool_rounds{$key}->delete();
						delete $rpool_rounds{$key};
					}
				}
				prune_unused( \%rpool_by_id, $translator{rpool}, $jdata->{room_pools});
			}

			#ROOM TIMEBLOCKS AND EVENT BLOCKS
			foreach my $site (@{$jdata->{sites}}) {

				my $osite = $translator{site}{$site->{id}};
				next unless $osite;

				my @blocks = Tab::RoomStrike->search_by_site($osite->id, $tourn->id);
				my %block_by_id = map {$_->id => $_} @blocks;

				if ($site->{blocks}) {

					foreach my $block (@{$site->{blocks}}) {

						my $oblock;
						$oblock = $block_by_id{$block->{id}};

						if ($oblock) {

							$oblock->type($block->{tag});
							$oblock->room($block->{room});

						} else {
							$oblock = Tab::RoomStrike->create({
								type => $block->{tag},
								room => $block->{room},
							});
						}

						my $start_dt = parse_date($block->{start});
						my $end_dt = parse_date($block->{end});

						$oblock->start($start_dt);
						$oblock->end($end_dt);

						foreach my $key ("event", "judge", "entry") {
							if ($block->{$key}) {
								my $obj = $translator{$key}{$block->{$key}};
								$oblock->$key($obj->id) if $obj > 0;
							}
						}
						$oblock->update();
						delete $block_by_id{$oblock->id};

						$translator{roomblock}{$block->{id}} = $oblock;
					}
					prune_unused( \%block_by_id, $translator{roomblock}, $site->{blocks});
				}
			}
		}
	}

	$m->flush_buffer() unless $no_return;

	if ($no_return eq "speechwire") {
		my $msg = "File uploaded";
		$m->redirect("/tabbing/publish/swdistrict.mhtml?msg=$msg");
	}

	$m->print("</span>");

	&outlog("<h5 class='centeralign redtext'>Data Upload Complete!</h5>");
	$m->print("</div>");
	$m->print("</div>");
	$m->print("</div>");
	$m->flush_buffer() unless $no_return;

	if ($round_id) {
		my $msg = "Round restored from backup";
		my $round = Tab::Round->retrieve($round_id);
        $m->comp("/funclib/round_audit.mas", round => $round);
		$m->redirect("/panel/schemat/show.mhtml?round_id=".$round->id."&msg=$msg");
	}

	$m->flush_buffer() unless $no_return;

	undef $no_return;

	sub parse_date {
		my $string = shift;
		$string =~ s/Z$//g;
		$string =~ s/T/ /g;

		my $dt = eval {
			return DateTime::Format::MySQL->parse_datetime($string);
		};
		return $dt;
	}

	sub parse_setting {

		my $json_ref = shift;

		return unless $json_ref->{tag};
		return unless $json_ref->{value};

		if ($json_ref->{meta} eq "date") {
			my $dt = parse_date($json_ref->{value});
			return unless $dt;
			return ($json_ref->{tag}, $json_ref->{meta}, $dt);
		} elsif ($json_ref->{meta} eq "text" || $json_ref->{meta} eq "json") {

			my $value = Tab::Utils::uncompress($json_ref->{value}) if $json_ref->{value};
			my $json = eval { return JSON::decode_json($value); };
			return ($json_ref->{tag}, $json_ref->{meta}, $json);

		} else {
			return ($json_ref->{tag}, $json_ref->{value});
		}
	}

	sub prune_unused {

		my ($objects, $translator, $json) = @_;

		my %taken;

		if (reftype($json) eq "ARRAY") {
			foreach my $value (@{$json}) {
				next unless $translator->{$value->{id}} > 0;
				$taken{$translator->{$value->{id}}}++;
			}
		} elsif (reftype($json) eq "HASH") {
			unless ($translator->{$json->{id}} > 0) {
				$taken{$translator->{$json->{id}}}++;
			}
		}

		if (reftype($objects) eq "HASH") {
			foreach my $key (keys %{$objects}) {
				next if $taken{$key};
				$objects->{$key}->delete;
				delete $objects->{$key};
			}
		}

		return;
	}

	sub errorlog {
		my $text = shift;
		$m->print('<span class="redtext semibold">');
		$m->print($text);
		$m->print('</span>');
	#	$m->print('{ "error": true, "message": "'.$text.'"}');
		$m->flush_buffer() unless $no_return;
	}

	sub outlog {
		my $text = shift;
		$m->print($text);
	#	$m->print('{ "error": false, "message": "'.$text.'"}');
		$m->flush_buffer() unless $no_return;
	}

	sub clean_rating {

		my ($rating, $nowstring, $translator, $category) = @_;

		my $entered = eval {
			return parse_date($rating->{entered});
		};

		unless ($entered) {
			$entered = $nowstring;
		}

		if ($rating->{rating_tier}) {
			my $tier = $translator->{rating_tier}{$rating->{rating_tier}};

			unless ($tier) {
				$tier = $translator->{rating_tier_name}{$category}{$rating->{rating_tier_name}};
			}

			if ($tier) {
				$rating->{rating_tier} = $tier;
			} else {
				$rating->{rating_tier} = 0;
			}
		} else {
			$rating->{rating_tier} = 0;
		}

		if ($rating->{rating_subset}) {
			my $subset = $translator->{rating_subset}{$rating->{rating_subset}};
			unless ($subset) {
				$subset = $translator->{rating_subset_name}{$category}{$rating->{rating_subset}};
			}
			if ($subset) {
				$rating->{rating_subset} = $subset;
			} else {
				$rating->{rating_subset} = 0;
			}
		} else {
			$rating->{rating_subset} = 0;
		}

		unless ($rating->{side}) {
			$rating->{side} = 0;
		}

		if ($translator->{entry}{$rating->{entry}}) {
			$rating->{entry} = $translator->{entry}{$rating->{entry}};
		} else {
			delete $rating->{entry};
		}

		if ($translator->{judge}{$rating->{judge}}) {
			$rating->{judge} = $translator->{judge}{$rating->{judge}};
		} else {
			delete $rating->{judge};
		}

		return $rating;
	}

</%init>
